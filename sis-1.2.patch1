diff -r -c sis-1.2/blif2vst/blif2vst.c /projects/sis/sis-devel/common/src/blif2vst/blif2vst.c
*** sis-1.2/blif2vst/blif2vst.c	Fri Jul 15 14:17:00 1994
--- /projects/sis/sis-devel/common/src/blif2vst/blif2vst.c	Tue Sep  6 17:39:25 1994
***************
*** 152,158 ****
      if (In!=stdin) (void)fclose(In);
      if (Out!=stdout) (void)fclose(Out);
  
! };
  
  
  /* -=[ Error ]=-                                    *
--- 152,158 ----
      if (In!=stdin) (void)fclose(In);
      if (Out!=stdout) (void)fclose(Out);
  
! }
  
  
  /* -=[ Error ]=-                                    *
***************
*** 166,172 ****
      (void)fprintf(stderr,"*** Error : %s\n",Msg);
      CloseAll();
      exit(1);
! };
  
  
  /* -=[ Warning ]=-                                  *
--- 166,172 ----
      (void)fprintf(stderr,"*** Error : %s\n",Msg);
      CloseAll();
      exit(1);
! }
  
  
  /* -=[ Warning ]=-                                  *
***************
*** 180,186 ****
  {
      if (DEBUG) (void)fprintf(stderr,"*parse warning* Line %u : %s\n",line,name);
  
! };
  
  
  /* -=[ SyntaxError ]=-                              *
--- 180,186 ----
  {
      if (DEBUG) (void)fprintf(stderr,"*parse warning* Line %u : %s\n",line,name);
  
! }
  
  
  /* -=[ SyntaxError ]=-                              *
***************
*** 198,204 ****
      (void)fprintf(stderr,"*Error* Line %u : object of the error : %s\n",line,obj);
      Error("Could not continue!");
  
! };
  
  
  /*[]-------==[ General Procedures ]==--------------------------------------[]*/
--- 198,204 ----
      (void)fprintf(stderr,"*Error* Line %u : object of the error : %s\n",line,obj);
      Error("Could not continue!");
  
! }
  
  
  /*[]-------==[ General Procedures ]==--------------------------------------[]*/
***************
*** 228,234 ****
  	len-=2;
      } else {
  	n=name;
!     };
      if ( len != (strlen(keywrd))) return 0;
      if (!len) return 0;
         /* if length 0 exit */
--- 228,234 ----
  	len-=2;
      } else {
  	n=name;
!     }
      if ( len != (strlen(keywrd))) return 0;
      if (!len) return 0;
         /* if length 0 exit */
***************
*** 238,244 ****
  	    return 0;
  	/* EoL, exit */
  	if ((*n=='\0') || (*n=='"')) break;
!     };
      return 1;
  }
  
--- 238,244 ----
  	    return 0;
  	/* EoL, exit */
  	if ((*n=='\0') || (*n=='"')) break;
!     }
      return 1;
  }
  
***************
*** 264,270 ****
      (void)fprintf(stderr,"Instance %s not found in library!\n",name);
      Error("could not continue");
      return (struct Cell *)NULL;
! };
  
  
  void ReleaseBit(ptr)
--- 264,270 ----
      (void)fprintf(stderr,"Instance %s not found in library!\n",name);
      Error("could not continue");
      return (struct Cell *)NULL;
! }
  
  
  void ReleaseBit(ptr)
***************
*** 278,285 ****
  	tmp=ptr2->next;
  	free((char *)ptr2);
  	ptr2=tmp;
!     };
! };
  
  
  struct Cell *NewCell(name,ports)
--- 278,285 ----
  	tmp=ptr2->next;
  	free((char *)ptr2);
  	ptr2=tmp;
!     }
! }
  
  
  struct Cell *NewCell(name,ports)
***************
*** 294,300 ****
      
      if ( (tmp=(struct Cell *)calloc(1,sizeof(struct Cell)))== NULL ) {
  	Error("Allocation Error or not enought memory !");
!     };
  
      if (ports!=NULL){
  	j=1;
--- 294,300 ----
      
      if ( (tmp=(struct Cell *)calloc(1,sizeof(struct Cell)))== NULL ) {
  	Error("Allocation Error or not enought memory !");
!     }
  
      if (ports!=NULL){
  	j=1;
***************
*** 301,312 ****
  	Bptr=ports;
  	while(Bptr->next!=NULL){
  	    j++; Bptr=Bptr->next;
! 	};
  	num=j;
  	
  	if ( (tmp->formals=(struct Ports *)calloc(1,j*sizeof(struct Ports)))==NULL){
  	    Error("Allocation Error or not enought memory !");
! 	};
  	(void)strcpy(tmp->name,name);
  	tmp->npins=j;
  	tmp->next=NULL;
--- 301,312 ----
  	Bptr=ports;
  	while(Bptr->next!=NULL){
  	    j++; Bptr=Bptr->next;
! 	}
  	num=j;
  	
  	if ( (tmp->formals=(struct Ports *)calloc(1,j*sizeof(struct Ports)))==NULL){
  	    Error("Allocation Error or not enought memory !");
! 	}
  	(void)strcpy(tmp->name,name);
  	tmp->npins=j;
  	tmp->next=NULL;
***************
*** 319,329 ****
  	    (void)strcpy(Pptr->name,Bptr->name);
  	    Bptr=Bptr->next;
  	    Pptr++; j++;
! 	};
  	ReleaseBit(ports);
      } else {
  	tmp->formals=NULL;
!     };
      return tmp;
  }
  
--- 319,329 ----
  	    (void)strcpy(Pptr->name,Bptr->name);
  	    Bptr=Bptr->next;
  	    Pptr++; j++;
! 	}
  	ReleaseBit(ports);
      } else {
  	tmp->formals=NULL;
!     }
      return tmp;
  }
  
***************
*** 337,351 ****
  
      if ( (tmp=(struct Instance *)calloc(1,sizeof(struct Instance)))== NULL ) {
  	Error("Allocation Error or not enought memory !");
!     };
      if (cell!=NULL){
  	i=cell->npins*sizeof(struct Ports);
  	if ( (tmp->actuals=(struct Ports *)calloc(1,i))==NULL){
  	    Error("Allocation Error or not enought memory !");
! 	};
      } else {
  	tmp->actuals=NULL;
!     };
      tmp->what=cell;
      tmp->next=NULL;
  
--- 337,351 ----
  
      if ( (tmp=(struct Instance *)calloc(1,sizeof(struct Instance)))== NULL ) {
  	Error("Allocation Error or not enought memory !");
!     }
      if (cell!=NULL){
  	i=cell->npins*sizeof(struct Ports);
  	if ( (tmp->actuals=(struct Ports *)calloc(1,i))==NULL){
  	    Error("Allocation Error or not enought memory !");
! 	}
      } else {
  	tmp->actuals=NULL;
!     }
      tmp->what=cell;
      tmp->next=NULL;
  
***************
*** 362,370 ****
      TYPEptr->VECTs=(struct VECTstruct *)calloc(1,sizeof(struct VECTstruct));
      if ( (TYPEptr==NULL) || (TYPEptr->BITs==NULL) || (TYPEptr->VECTs==NULL) ) {
  	Error("Allocation Error or not enought memory !");
!     };
      return TYPEptr;
! };
  
  struct MODELstruct *NewModel()
  {
--- 362,370 ----
      TYPEptr->VECTs=(struct VECTstruct *)calloc(1,sizeof(struct VECTstruct));
      if ( (TYPEptr==NULL) || (TYPEptr->BITs==NULL) || (TYPEptr->VECTs==NULL) ) {
  	Error("Allocation Error or not enought memory !");
!     }
      return TYPEptr;
! }
  
  struct MODELstruct *NewModel()
  {
***************
*** 372,378 ****
      
      if ((LocModel=(struct MODELstruct *)calloc(1,sizeof (struct MODELstruct))) ==NULL) {
  	Error("Not enought memory or allocation error");
!     };
      
      LocModel->Inputs=NewTYPE();
      LocModel->Outputs=NewTYPE();
--- 372,378 ----
      
      if ((LocModel=(struct MODELstruct *)calloc(1,sizeof (struct MODELstruct))) ==NULL) {
  	Error("Not enought memory or allocation error");
!     }
      
      LocModel->Inputs=NewTYPE();
      LocModel->Outputs=NewTYPE();
***************
*** 392,404 ****
     (*VECTptr)->next=(struct VECTstruct *)calloc(1,sizeof(struct VECTstruct));
     if ( (*VECTptr)->next==NULL) {
  	Error("Allocation Error or not enought memory !");
!     };
     (*VECTptr)=(*VECTptr)->next;
     (void)strcpy((*VECTptr)->name,name);
     (*VECTptr)->start=a;
     (*VECTptr)->end=b;
     (*VECTptr)->next=NULL;
! };
  
  void AddBIT(BITptr,name)
  struct BITstruct **BITptr;
--- 392,404 ----
     (*VECTptr)->next=(struct VECTstruct *)calloc(1,sizeof(struct VECTstruct));
     if ( (*VECTptr)->next==NULL) {
  	Error("Allocation Error or not enought memory !");
!     }
     (*VECTptr)=(*VECTptr)->next;
     (void)strcpy((*VECTptr)->name,name);
     (*VECTptr)->start=a;
     (*VECTptr)->end=b;
     (*VECTptr)->next=NULL;
! }
  
  void AddBIT(BITptr,name)
  struct BITstruct **BITptr;
***************
*** 408,418 ****
     (*BITptr)->next=(struct BITstruct *)calloc(1,sizeof(struct BITstruct));
     if ( (*BITptr)->next==NULL) {
  	Error("Allocation Error or not enought memory !");
!     };
     (*BITptr)=(*BITptr)->next;
     (void)strcpy((*BITptr)->name,name);
     (*BITptr)->next=NULL;
! };
  
  /*
  void AddTMP(TMPptr)
--- 408,418 ----
     (*BITptr)->next=(struct BITstruct *)calloc(1,sizeof(struct BITstruct));
     if ( (*BITptr)->next==NULL) {
  	Error("Allocation Error or not enought memory !");
!     }
     (*BITptr)=(*BITptr)->next;
     (void)strcpy((*BITptr)->name,name);
     (*BITptr)->next=NULL;
! }
  
  /*
  void AddTMP(TMPptr)
***************
*** 421,431 ****
  
     (*TMPptr)->next=(struct TMPstruct *)calloc(1,sizeof(struct TMPstruct));
     if ( (*TMPptr)->next==NULL) {
! 	Error("Allocation Error or not enought memory !");
!     };
     (*TMPptr)=(*TMPptr)->next;
  
! };
  */
  
  struct BITstruct *IsHere(name,ptr)
--- 421,431 ----
  
     (*TMPptr)->next=(struct TMPstruct *)calloc(1,sizeof(struct TMPstruct));
     if ( (*TMPptr)->next==NULL) {
! 	Error("Allocation Error or not enough memory !");
!     }
     (*TMPptr)=(*TMPptr)->next;
  
! }
  */
  
  struct BITstruct *IsHere(name,ptr)
***************
*** 438,446 ****
      while(BITptr->next!=NULL){
  	BITptr=BITptr->next;
  	if (KwrdCmp(name,BITptr->name)) return BITptr;
!     };
      return (struct BITstruct *)NULL;
! };
  
  /*
  struct BITstruct *IsKnown(name,model)
--- 438,446 ----
      while(BITptr->next!=NULL){
  	BITptr=BITptr->next;
  	if (KwrdCmp(name,BITptr->name)) return BITptr;
!     }
      return (struct BITstruct *)NULL;
! }
  
  /*
  struct BITstruct *IsKnown(name,model)
***************
*** 484,490 ****
  	next=tZERO;
  	str=0;
  	line=0;
!     };
  
      t=&(TOKEN[0]);
      num=0;
--- 484,490 ----
  	next=tZERO;
  	str=0;
  	line=0;
!     }
  
      t=&(TOKEN[0]);
      num=0;
***************
*** 496,502 ****
  	} else {
  	    c=fgetc(In);
  	    if (c=='\n') line++;
! 	};
  	if (feof(In)) next=tEOF;
  	ready=0;
  	sentback='\0';
--- 496,502 ----
  	} else {
  	    c=fgetc(In);
  	    if (c=='\n') line++;
! 	}
  	if (feof(In)) next=tEOF;
  	ready=0;
  	sentback='\0';
***************
*** 525,534 ****
  			    next=tLONG;
  			    ready=0;
  			    sentback=c;
! 			};
! 		    };
! 		};
! 	    };
  	    break;
  	  case tLONG:
  	    if (DEBUG) (void)fprintf(stderr,"\n-> LONG, c=%c  token=%s",c,TOKEN);
--- 525,534 ----
  			    next=tLONG;
  			    ready=0;
  			    sentback=c;
! 			}
! 		    }
! 		}
! 	    }
  	    break;
  	  case tLONG:
  	    if (DEBUG) (void)fprintf(stderr,"\n-> LONG, c=%c  token=%s",c,TOKEN);
***************
*** 555,564 ****
  			    next=tLONG;
  			    if ( (ready=(num>=MAXTOKENLEN-1)) )
  			    (void)fprintf(stderr,"Sorry, exeeded max name len of %u",num+1);
! 			};
! 		    };
! 		};
! 	    };
  	    break;
  	  case tSTRING:
  #if defined(DBG)
--- 555,564 ----
  			    next=tLONG;
  			    if ( (ready=(num>=MAXTOKENLEN-1)) )
  			    (void)fprintf(stderr,"Sorry, exeeded max name len of %u",num+1);
! 			}
! 		    }
! 		}
! 	    }
  	    break;
  	  case tSTRING:
  #if defined(DBG)
***************
*** 567,579 ****
  	    if (!str) {
  		*t='"'; t++; num++;
  		str=1;
! 	    };
  		*t=c; t++; num++;
  	    if (c=='"') {   /* last dblquote */
  		ready=1;
  		next=tZERO;
  		break;
! 	    };
  	    next=tSTRING;
  	    if ( (ready=(num>=MAXTOKENLEN-1)) )
  		(void)fprintf(stderr,"Sorry, exeeded max name len of %u",num+1);
--- 567,579 ----
  	    if (!str) {
  		*t='"'; t++; num++;
  		str=1;
! 	    }
  		*t=c; t++; num++;
  	    if (c=='"') {   /* last dblquote */
  		ready=1;
  		next=tZERO;
  		break;
! 	    }
  	    next=tSTRING;
  	    if ( (ready=(num>=MAXTOKENLEN-1)) )
  		(void)fprintf(stderr,"Sorry, exeeded max name len of %u",num+1);
***************
*** 584,590 ****
  	    if isEOL(c) {
  		sentback=c; /* in this case EOL must be given to the caller */ 
  		next = tZERO;
! 	    };
  	    break;  
  	  case tCONT:
  #if defined(DBG)
--- 584,590 ----
  	    if isEOL(c) {
  		sentback=c; /* in this case EOL must be given to the caller */ 
  		next = tZERO;
! 	    }
  	    break;  
  	  case tCONT:
  #if defined(DBG)
***************
*** 595,601 ****
  		next = tZERO;
  	    } else {
  		next=tCONT;
! 	    };
  	    break;
  	  case tEOF:
  #if defined(DBG)
--- 595,601 ----
  		next = tZERO;
  	    } else {
  		next=tCONT;
! 	    }
  	    break;
  	  case tEOF:
  #if defined(DBG)
***************
*** 611,621 ****
  	    (void)fprintf(stderr,"\n-------> DEFAULT, c=%c  token=%s",c,TOKEN);
  #endif
  	      next=tZERO;
! 	};
      } while(!ready);
      *t='\0';
      (void)strcpy(tok,&(TOKEN[0]));
! };
  
  
  void PrintGates(cell)
--- 611,621 ----
  	    (void)fprintf(stderr,"\n-------> DEFAULT, c=%c  token=%s",c,TOKEN);
  #endif
  	      next=tZERO;
! 	}
      } while(!ready);
      *t='\0';
      (void)strcpy(tok,&(TOKEN[0]));
! }
  
  
  void PrintGates(cell)
***************
*** 630,638 ****
  	ptr=cell->formals;
  	for(j=0; j<cell->npins; j++, ptr++){
  	    if (DEBUG) (void)fprintf(stderr,"\tpin %d : %s\n",j,ptr->name);
! 	};
!     };
! };
  
  /*[]------------------[]*/
  
--- 630,638 ----
  	ptr=cell->formals;
  	for(j=0; j<cell->npins; j++, ptr++){
  	    if (DEBUG) (void)fprintf(stderr,"\tpin %d : %s\n",j,ptr->name);
! 	}
!     }
! }
  
  /*[]------------------[]*/
  
***************
*** 663,669 ****
  	init=1;
  	next=tZERO;
  	str=0;
!     };
  
      t=&(TOKEN[0]);
      num=0;
--- 663,669 ----
  	init=1;
  	next=tZERO;
  	str=0;
!     }
  
      t=&(TOKEN[0]);
      num=0;
***************
*** 674,680 ****
  	    c=sentback;
  	} else {
  	    c=fgetc(Lib);
! 	};
  	if (feof(Lib)) next=tEOF;
  	ready=0;
  	sentback='\0';
--- 674,680 ----
  	    c=sentback;
  	} else {
  	    c=fgetc(Lib);
! 	}
  	if (feof(Lib)) next=tEOF;
  	ready=0;
  	sentback='\0';
***************
*** 700,709 ****
  			    next=tLONG;
  			    ready=0;
  			    sentback=c;
! 			};
! 		    };
! 		};
! 	    };
  	    break;
  	  case tLONG:
  	    if ((c==' ') || (c=='\r') || (c=='\t')){
--- 700,709 ----
  			    next=tLONG;
  			    ready=0;
  			    sentback=c;
! 			}
! 		    }
! 		}
! 	    }
  	    break;
  	  case tLONG:
  	    if ((c==' ') || (c=='\r') || (c=='\t')){
***************
*** 728,738 ****
  			    next=tLONG;
  			    if ( (ready=(num>=MAXTOKENLEN-1)) )
  				(void)fprintf(stderr,"Sorry, exeeded max name len of %u",num+1);
! 			};
! 		    };
! 		};
  		    
! 	    };
  	    break;
  	  case tSTRING:
  	    if (!str) {
--- 728,738 ----
  			    next=tLONG;
  			    if ( (ready=(num>=MAXTOKENLEN-1)) )
  				(void)fprintf(stderr,"Sorry, exeeded max name len of %u",num+1);
! 			}
! 		    }
! 		}
  		    
! 	    }
  	    break;
  	  case tSTRING:
  	    if (!str) {
***************
*** 739,745 ****
  		*t='"'; t++; num++;
  		if(DEBUG) (void)fprintf(stderr,"<%c>\n",c);
  		str=1;
! 	    };
  	    *t=c; t++; num++;
  	    if (c=='"') {   /* last dblquote */
  		    ready=1;
--- 739,745 ----
  		*t='"'; t++; num++;
  		if(DEBUG) (void)fprintf(stderr,"<%c>\n",c);
  		str=1;
! 	    }
  	    *t=c; t++; num++;
  	    if (c=='"') {   /* last dblquote */
  		    ready=1;
***************
*** 746,752 ****
  		    next=tZERO;
  		    if (DEBUG) fprintf(stderr,"STRING : %s\n",TOKEN);
  		    break;
! 		};
  	    next=tSTRING;
  	    if ( (ready=(num>=MAXTOKENLEN-1)) )
  		(void)fprintf(stderr,"Sorry, exeeded max name len of %u",num+1);
--- 746,752 ----
  		    next=tZERO;
  		    if (DEBUG) fprintf(stderr,"STRING : %s\n",TOKEN);
  		    break;
! 		}
  	    next=tSTRING;
  	    if ( (ready=(num>=MAXTOKENLEN-1)) )
  		(void)fprintf(stderr,"Sorry, exeeded max name len of %u",num+1);
***************
*** 763,777 ****
  	    if (c=='\n'){
  		sentback=c;
  		next=tZERO;
! 	    };
  	    break;
  	  default :
  	      next=tZERO;
! 	};
      } while(!ready);
      *t='\0';
      (void)strcpy(tok,&(TOKEN[0]));
! };
  
  
  /* -=[ ScanLibrary ]=-                              *
--- 763,777 ----
  	    if (c=='\n'){
  		sentback=c;
  		next=tZERO;
! 	    }
  	    break;
  	  default :
  	      next=tZERO;
! 	}
      } while(!ready);
      *t='\0';
      (void)strcpy(tok,&(TOKEN[0]));
! }
  
  
  /* -=[ ScanLibrary ]=-                              *
***************
*** 827,834 ****
  		    GetLibToken(Lib,s);   /* area */
  		    next=sPIN;
  		    if (DEBUG) (void)fprintf(stderr,"Latch name: %s\n",name);
! 		};
! 	    };
  	    break;
  	  case sPIN:
  	    if ( !( ((*s>=0x27) && (*s<=0x2b)) || (*s=='=') || (*s=='!')|| (*s==';')) ){
--- 827,834 ----
  		    GetLibToken(Lib,s);   /* area */
  		    next=sPIN;
  		    if (DEBUG) (void)fprintf(stderr,"Latch name: %s\n",name);
! 		}
! 	    }
  	    break;
  	  case sPIN:
  	    if ( !( ((*s>=0x27) && (*s<=0x2b)) || (*s=='=') || (*s=='!')|| (*s==';')) ){
***************
*** 842,858 ****
  		if (IsHere(s,&firstBIT)==NULL) {
  		    if (DEBUG) (void)fprintf(stderr,"\tunknown pin : %s\n",s);
  		    AddBIT(&tmpBIT,s);
! 		};
! 	    };
  	    if (*s==';') {
  		if (latch) {
  		    next=sCLOCK;
  		} else {
  		    next=sADDCELL;
! 		};
  	    } else {
  		next=sPIN;
! 	    };
  	    break;
  	  case sCLOCK:
  	    if (KwrdCmp(s,"CONTROL")){
--- 842,858 ----
  		if (IsHere(s,&firstBIT)==NULL) {
  		    if (DEBUG) (void)fprintf(stderr,"\tunknown pin : %s\n",s);
  		    AddBIT(&tmpBIT,s);
! 		}
! 	    }
  	    if (*s==';') {
  		if (latch) {
  		    next=sCLOCK;
  		} else {
  		    next=sADDCELL;
! 		}
  	    } else {
  		next=sPIN;
! 	    }
  	    break;
  	  case sCLOCK:
  	    if (KwrdCmp(s,"CONTROL")){
***************
*** 862,868 ****
  		next=sADDCELL;
  	    } else {
  		next=sCLOCK;
! 	    };
  	    break;
  	  case sADDCELL:
  	    if (DEBUG) (void)fprintf(stderr,"\tadding cell to library\n");
--- 862,868 ----
  		next=sADDCELL;
  	    } else {
  		next=sCLOCK;
! 	    }
  	    break;
  	  case sADDCELL:
  	    if (DEBUG) (void)fprintf(stderr,"\tadding cell to library\n");
***************
*** 871,887 ****
  	    cell=cell->next;
  	    next=sZERO;
  	    break;
! 	};
      } while (!feof(Lib));
  
      if ((first.next)->next==NULL) {
  	(void)sprintf("Library file %s does *NOT* contains gates !",LibName);
  	Error("could not continue with an empy library");
!     };
      if (DEBUG) (void)fprintf(stderr,"eond of lib");
      PrintGates(first.next);
      return first.next;
! };
  
  
  /* -=[ CheckArgs ]=-                                *
--- 871,887 ----
  	    cell=cell->next;
  	    next=sZERO;
  	    break;
! 	}
      } while (!feof(Lib));
  
      if ((first.next)->next==NULL) {
  	(void)sprintf("Library file %s does *NOT* contains gates !",LibName);
  	Error("could not continue with an empy library");
!     }
      if (DEBUG) (void)fprintf(stderr,"eond of lib");
      PrintGates(first.next);
      return first.next;
! }
  
  
  /* -=[ CheckArgs ]=-                                *
***************
*** 903,909 ****
      extern int optind;
  
      s=&( argv[0][strlen(argv[0])-1] );
!     while( (s>= &(argv[0][0])) && (*s!='/') ) {  s--; };
      (void)fprintf(stderr,"\t\t      Blif Converter v1.0\n");
      (void)fprintf(stderr,"\t\t      by Roberto Rambaldi\n");
      (void)fprintf(stderr,"\t\tD.E.I.S. Universita' di Bologna\n\n");
--- 903,909 ----
      extern int optind;
  
      s=&( argv[0][strlen(argv[0])-1] );
!     while( (s>= &(argv[0][0])) && (*s!='/') ) {  s--; }
      (void)fprintf(stderr,"\t\t      Blif Converter v1.0\n");
      (void)fprintf(stderr,"\t\t      by Roberto Rambaldi\n");
      (void)fprintf(stderr,"\t\tD.E.I.S. Universita' di Bologna\n\n");
***************
*** 937,944 ****
  	    (void)fprintf(stderr,"\t *** unknown options");
  	    help=1;
  	    break;
! 	};
!     };	    
  
      if (!help) {
          if (optind>=argc) {
--- 937,944 ----
  	    (void)fprintf(stderr,"\t *** unknown options");
  	    help=1;
  	    break;
! 	}
!     }	    
  
      if (!help) {
          if (optind>=argc) {
***************
*** 952,959 ****
  		if ((In=fopen(argv[optind],"rt"))==NULL) Error("Couldn't read input file");
  		if (++optind>=argc) { Out=stdout; }
  		else if ((Out=fopen(argv[optind],"wt"))==NULL) Error("Could'n make opuput file");
! 	    };
! 	};
  	
  	if (!ADDPOWER) {
  	    VDD[0]='\0'; VSS[0]='\0';
--- 952,959 ----
  		if ((In=fopen(argv[optind],"rt"))==NULL) Error("Couldn't read input file");
  		if (++optind>=argc) { Out=stdout; }
  		else if ((Out=fopen(argv[optind],"wt"))==NULL) Error("Could'n make opuput file");
! 	    }
! 	}
  	
  	if (!ADDPOWER) {
  	    VDD[0]='\0'; VSS[0]='\0';
***************
*** 960,967 ****
  	} else {
  	    if (VDD[0]=='\0') (void)strcpy(VDD,"vdd");
  	    if (VSS[0]=='\0') (void)strcpy(VSS,"vss");
! 	};
!     };
  
      if (help) {
  	(void)fprintf(stderr,"\tUsage: %s [options] <library> [infile [outfile]]\n",s);
--- 960,967 ----
  	} else {
  	    if (VDD[0]=='\0') (void)strcpy(VDD,"vdd");
  	    if (VSS[0]=='\0') (void)strcpy(VSS,"vss");
! 	}
!     }
  
      if (help) {
  	(void)fprintf(stderr,"\tUsage: %s [options] <library> [infile [outfile]]\n",s);
***************
*** 975,982 ****
  	(void)fprintf(stderr,"\t-h\t\t prints these lines");
  	(void)fprintf(stderr,"\n\tIf no VDD or VSS nets are given VDD and VSS will be used\n");
  	exit(0);
!     };
! };
  
  
  
--- 975,982 ----
  	(void)fprintf(stderr,"\t-h\t\t prints these lines");
  	(void)fprintf(stderr,"\n\tIf no VDD or VSS nets are given VDD and VSS will be used\n");
  	exit(0);
!     }
! }
  
  
  
***************
*** 997,1005 ****
      for(s=string; *s!='\0'; s++)
  	if (!isdigit(*s)) {
  	    SyntaxError("Expected decimal integer number",string);
! 	};
      return atoi(string);
! };
  
  /* -=[ GetSignals ]=-                               */
  
--- 997,1005 ----
      for(s=string; *s!='\0'; s++)
  	if (!isdigit(*s)) {
  	    SyntaxError("Expected decimal integer number",string);
! 	}
      return atoi(string);
! }
  
  /* -=[ GetSignals ]=-                               */
  
***************
*** 1023,1032 ****
  
      while(BITptr->next!=NULL) { 
  /*	(void)fprintf(stderr,".. b) element used : %s, skip...\n",BITptr->name); */
! 	BITptr=BITptr->next; };
      while(VECTptr->next!=NULL) { 
  /*	(void)fprintf(stderr,".. v) element used : %s, skip...\n",VECTptr->name); */
! 	VECTptr=VECTptr->next; };
  
      next = sZERO;
      Token=1;
--- 1023,1032 ----
  
      while(BITptr->next!=NULL) { 
  /*	(void)fprintf(stderr,".. b) element used : %s, skip...\n",BITptr->name); */
! 	BITptr=BITptr->next; }
      while(VECTptr->next!=NULL) { 
  /*	(void)fprintf(stderr,".. v) element used : %s, skip...\n",VECTptr->name); */
! 	VECTptr=VECTptr->next; }
  
      next = sZERO;
      Token=1;
***************
*** 1043,1049 ****
  		(void)sprintf(name,"intrnl%s",w+1);
  	    } else {
  		(void)strcpy(name,w);
! 	    };
  	    if (DEBUG) (void)fprintf(stderr,"element name : %s\n",name);
  	    next=sWAIT;
  	    break;
--- 1043,1049 ----
  		(void)sprintf(name,"intrnl%s",w+1);
  	    } else {
  		(void)strcpy(name,w);
! 	    }
  	    if (DEBUG) (void)fprintf(stderr,"element name : %s\n",name);
  	    next=sWAIT;
  	    break;
***************
*** 1058,1064 ****
  		AddBIT(&BITptr,name);
  		Token=0;
  		next=sZERO;
! 	    };
  	    break;
  	  case sNUM:
  	    if (DEBUG) (void)fprintf(stderr,"\t\t is a vector, element number :%s\n",w); 
--- 1058,1064 ----
  		AddBIT(&BITptr,name);
  		Token=0;
  		next=sZERO;
! 	    }
  	    break;
  	  case sNUM:
  	    if (DEBUG) (void)fprintf(stderr,"\t\t is a vector, element number :%s\n",w); 
***************
*** 1072,1081 ****
  	    if (*w!=')') {
  	        Warning("closing ) expected !");
  		Token=0;
! 	    };
  	    next=sZERO;
  	    break;
! 	};
  	if (DEBUG) (void)fprintf(stderr,"next = %u\n",next);
      } while(!feof(In));
  
--- 1072,1081 ----
  	    if (*w!=')') {
  	        Warning("closing ) expected !");
  		Token=0;
! 	    }
  	    next=sZERO;
  	    break;
! 	}
  	if (DEBUG) (void)fprintf(stderr,"next = %u\n",next);
      } while(!feof(In));
  
***************
*** 1109,1122 ****
  		} else {
  		    if (ptr->start<actual->start) {
  			actual->start=ptr->start;
! 		    };
! 		};
  		if (ptr->end>last) dir++;
  		else {
  		    if (ptr->end==last) {
  			Error("Two elements of an i/o vector with the same number not allowed!");
  		    } else dir--;
! 		};
  		/* release memory */
  		tmp=ptr->next;
  /*		(void)fprintf(stderr,"deleting element @%p, actual=%p  ..->next=%p\n",ptr,actual,actual->next); */
--- 1109,1122 ----
  		} else {
  		    if (ptr->start<actual->start) {
  			actual->start=ptr->start;
! 		    }
! 		}
  		if (ptr->end>last) dir++;
  		else {
  		    if (ptr->end==last) {
  			Error("Two elements of an i/o vector with the same number not allowed!");
  		    } else dir--;
! 		}
  		/* release memory */
  		tmp=ptr->next;
  /*		(void)fprintf(stderr,"deleting element @%p, actual=%p  ..->next=%p\n",ptr,actual,actual->next); */
***************
*** 1123,1129 ****
  		if (ptr==actual->next) {
  /*		    (void)fprintf(stderr,"updating actual's next"); */
  		    actual->next=tmp;
! 		};
  		free((char *)ptr);
  		ptr=tmp;
  		prev->next=tmp;
--- 1123,1129 ----
  		if (ptr==actual->next) {
  /*		    (void)fprintf(stderr,"updating actual's next"); */
  		    actual->next=tmp;
! 		}
  		free((char *)ptr);
  		ptr=tmp;
  		prev->next=tmp;
***************
*** 1130,1140 ****
  	    } else {
  		prev=ptr;
  		ptr=ptr->next;
! 	    };
! 	};
  	actual->dir=dir>0;
!     };
! };
  
  
  
--- 1130,1140 ----
  	    } else {
  		prev=ptr;
  		ptr=ptr->next;
! 	    }
! 	}
  	actual->dir=dir>0;
!     }
! }
  
  
  
***************
*** 1149,1155 ****
      while(BITptr->next!=NULL){
  	BITptr=BITptr->next;
  	if (DEBUG) (void)fprintf(stderr,"\t%s",BITptr->name);
!     };
  
      BITptr=(Model->Outputs)->BITs;
      if (DEBUG) (void)fprintf(stderr,"\nOUTPUTS, BIT:");
--- 1149,1155 ----
      while(BITptr->next!=NULL){
  	BITptr=BITptr->next;
  	if (DEBUG) (void)fprintf(stderr,"\t%s",BITptr->name);
!     }
  
      BITptr=(Model->Outputs)->BITs;
      if (DEBUG) (void)fprintf(stderr,"\nOUTPUTS, BIT:");
***************
*** 1156,1162 ****
      while(BITptr->next!=NULL){
  	BITptr=BITptr->next;
  	if (DEBUG) (void)fprintf(stderr,"\t%s",BITptr->name);
!     };
  
  
      VECTptr=(Model->Inputs)->VECTs;
--- 1156,1162 ----
      while(BITptr->next!=NULL){
  	BITptr=BITptr->next;
  	if (DEBUG) (void)fprintf(stderr,"\t%s",BITptr->name);
!     }
  
  
      VECTptr=(Model->Inputs)->VECTs;
***************
*** 1165,1171 ****
  	VECTptr=VECTptr->next;
  	if (VECTptr->dir) if (DEBUG) (void)fprintf(stderr,"\t%s [%d..%d]",VECTptr->name,VECTptr->start,VECTptr->end);
  	else if (DEBUG) (void)fprintf(stderr,"\t%s [%d..%d]",VECTptr->name,VECTptr->end,VECTptr->start);
!     };
  
      VECTptr=(Model->Outputs)->VECTs;
      if (DEBUG) (void)fprintf(stderr,"\nOUTPUTS, VECT:");
--- 1165,1171 ----
  	VECTptr=VECTptr->next;
  	if (VECTptr->dir) if (DEBUG) (void)fprintf(stderr,"\t%s [%d..%d]",VECTptr->name,VECTptr->start,VECTptr->end);
  	else if (DEBUG) (void)fprintf(stderr,"\t%s [%d..%d]",VECTptr->name,VECTptr->end,VECTptr->start);
!     }
  
      VECTptr=(Model->Outputs)->VECTs;
      if (DEBUG) (void)fprintf(stderr,"\nOUTPUTS, VECT:");
***************
*** 1173,1181 ****
  	VECTptr=VECTptr->next;
  	if (VECTptr->dir) if (DEBUG) (void)fprintf(stderr,"\t%s [%d..%d]",VECTptr->name,VECTptr->start,VECTptr->end);
  	else if (DEBUG) (void)fprintf(stderr,"\t%s [%d..%d]",VECTptr->name,VECTptr->end,VECTptr->start);
!     };
      if (DEBUG) (void)fprintf(stderr,"\n");
! };
  
  
  void PrintNet(cell)
--- 1173,1181 ----
  	VECTptr=VECTptr->next;
  	if (VECTptr->dir) if (DEBUG) (void)fprintf(stderr,"\t%s [%d..%d]",VECTptr->name,VECTptr->start,VECTptr->end);
  	else if (DEBUG) (void)fprintf(stderr,"\t%s [%d..%d]",VECTptr->name,VECTptr->end,VECTptr->start);
!     }
      if (DEBUG) (void)fprintf(stderr,"\n");
! }
  
  
  void PrintNet(cell)
***************
*** 1192,1200 ****
  	ptr2=(cell->what)->formals;
  	for(j=0; j<(cell->what)->npins; j++, ptr1++, ptr2++){
  	    if (DEBUG) (void)fprintf(stderr,"\tpin %d : %s -> %s\n",j,ptr2->name,ptr1->name);
! 	};
!     };
! };
  
  struct Instance *GetNames(name,type,Model)
  char *name;
--- 1192,1200 ----
  	ptr2=(cell->what)->formals;
  	for(j=0; j<(cell->what)->npins; j++, ptr1++, ptr2++){
  	    if (DEBUG) (void)fprintf(stderr,"\tpin %d : %s -> %s\n",j,ptr2->name,ptr1->name);
! 	}
!     }
! }
  
  struct Instance *GetNames(name,type,Model)
  char *name;
***************
*** 1231,1237 ****
      Bptr=(Model->Internals)->BITs;
      while(Bptr->next!=NULL){
  	Bptr=Bptr->next;
!     };
  
      do {
  	if (Token) GetToken(w);
--- 1231,1237 ----
      Bptr=(Model->Internals)->BITs;
      while(Bptr->next!=NULL){
  	Bptr=Bptr->next;
!     }
  
      do {
  	if (Token) GetToken(w);
***************
*** 1241,1248 ****
  	    if (next!=sADDINSTANCE) {
  		Warning("--------> Unexpected end of line!");
  		next=sADDINSTANCE;
! 	    };
! 	};
  	switch (next) {
  	  case sZERO:
  	    if (*w=='[') {
--- 1241,1248 ----
  	    if (next!=sADDINSTANCE) {
  		Warning("--------> Unexpected end of line!");
  		next=sADDINSTANCE;
! 	    }
! 	}
  	switch (next) {
  	  case sZERO:
  	    if (*w=='[') {
***************
*** 1250,1256 ****
  		(void)sprintf(FORMname,"intrnl%s",w+1);
  	    } else {
  		(void)strcpy(FORMname,w);
! 	    };
  	    if (DEBUG) (void)fprintf(stderr,"formal element name : %s\n",FORMname); 
  	    next=sfWAIT;
  	    break;
--- 1250,1256 ----
  		(void)sprintf(FORMname,"intrnl%s",w+1);
  	    } else {
  		(void)strcpy(FORMname,w);
! 	    }
  	    if (DEBUG) (void)fprintf(stderr,"formal element name : %s\n",FORMname); 
  	    next=sfWAIT;
  	    break;
***************
*** 1262,1268 ****
  		/* it was a BIT type */
  		Token=0;
  		next=sEQUAL;
! 	    };
  	    break;
  	  case sfNUM:
  	    if (DEBUG) (void)fprintf(stderr,"\t\t is a vector, element number :%s\n",w); 
--- 1262,1268 ----
  		/* it was a BIT type */
  		Token=0;
  		next=sEQUAL;
! 	    }
  	    break;
  	  case sfNUM:
  	    if (DEBUG) (void)fprintf(stderr,"\t\t is a vector, element number :%s\n",w); 
***************
*** 1275,1281 ****
  	    if (*w!=')') {
  	        Warning("Closing ) expected !");
  		Token=0;
! 	    };
  	    next=sEQUAL;
  	    break;
  	  case sEQUAL:
--- 1275,1281 ----
  	    if (*w!=')') {
  	        Warning("Closing ) expected !");
  		Token=0;
! 	    }
  	    next=sEQUAL;
  	    break;
  	  case sEQUAL:
***************
*** 1289,1297 ****
  		} else {
  		    Warning("Expexted '=' !");
  		    next=saNAME;
! 		};
  		Token=0;
! 	    };
  	    break;
  	  case saNAME:
  	    if (*w=='[') {
--- 1289,1297 ----
  		} else {
  		    Warning("Expexted '=' !");
  		    next=saNAME;
! 		}
  		Token=0;
! 	    }
  	    break;
  	  case saNAME:
  	    if (*w=='[') {
***************
*** 1299,1305 ****
  		(void)sprintf(ACTname,"intrnl%s",w+1);
  	    } else {
  		(void)strcpy(ACTname,w);
! 	    };
  	    if (DEBUG) (void)fprintf(stderr,"actual element name : %s\n",ACTname); 
  	    next=saWAIT;
  	    break;
--- 1299,1305 ----
  		(void)sprintf(ACTname,"intrnl%s",w+1);
  	    } else {
  		(void)strcpy(ACTname,w);
! 	    }
  	    if (DEBUG) (void)fprintf(stderr,"actual element name : %s\n",ACTname); 
  	    next=saWAIT;
  	    break;
***************
*** 1311,1317 ****
  		/* it was a BIT type */
  		Token=0;
  		next=sADDINSTANCE;
! 	    };
  	    break;
  	  case saNUM:
  	    if (DEBUG) (void)fprintf(stderr,"\t\t is a vector, element number :%s\n",w); 
--- 1311,1317 ----
  		/* it was a BIT type */
  		Token=0;
  		next=sADDINSTANCE;
! 	    }
  	    break;
  	  case saNUM:
  	    if (DEBUG) (void)fprintf(stderr,"\t\t is a vector, element number :%s\n",w); 
***************
*** 1324,1330 ****
  	    if (*w!=')') {
  	        Warning("Closing ) expected !");
  		Token=0;
! 	    };
  	    next=sADDINSTANCE;
  	    break;
  	  case sADDINSTANCE:
--- 1324,1330 ----
  	    if (*w!=')') {
  	        Warning("Closing ) expected !");
  		Token=0;
! 	    }
  	    next=sADDINSTANCE;
  	    break;
  	  case sADDINSTANCE:
***************
*** 1333,1339 ****
  		(IsHere(ACTname,(Model->Internals)->BITs)==NULL) ) {
  		AddBIT(&Bptr,ACTname);
  		if (DEBUG) (void)fprintf(stderr,"\tadded to internals\n");
! 	    };
  	    Aptr=Inst->actuals;
  	    Fptr=cell->formals;
  	    j=0; next=sZERO; 
--- 1333,1339 ----
  		(IsHere(ACTname,(Model->Internals)->BITs)==NULL) ) {
  		AddBIT(&Bptr,ACTname);
  		if (DEBUG) (void)fprintf(stderr,"\tadded to internals\n");
! 	    }
  	    Aptr=Inst->actuals;
  	    Fptr=cell->formals;
  	    j=0; next=sZERO; 
***************
*** 1344,1360 ****
  		    if (KwrdCmp(Fptr->name,FORMname)){
  			(void)strcpy(Aptr->name,ACTname);
  			break;
! 		    };
  		    Fptr++;
  		    Aptr++; 
  		    j++;
! 		};
  	    } else {
  		Aptr+=cell->npins-1;
  		(void)strcpy(Aptr->name,ACTname);
  		break;
! 	    };
! 	};
      } while(exit);
      return Inst;
  }
--- 1344,1360 ----
  		    if (KwrdCmp(Fptr->name,FORMname)){
  			(void)strcpy(Aptr->name,ACTname);
  			break;
! 		    }
  		    Fptr++;
  		    Aptr++; 
  		    j++;
! 		}
  	    } else {
  		Aptr+=cell->npins-1;
  		(void)strcpy(Aptr->name,ACTname);
  		break;
! 	    }
! 	}
      } while(exit);
      return Inst;
  }
***************
*** 1393,1400 ****
  	    if (init) (void)fputs(" ;\n",Out);
  	    else init=1;
  	    (void)fprintf(Out,"\t%s\t: in BIT",Bptr->name);
! 	};
!     };
  
      Bptr=(Model->Outputs)->BITs;
      while(Bptr->next!=NULL){
--- 1393,1400 ----
  	    if (init) (void)fputs(" ;\n",Out);
  	    else init=1;
  	    (void)fprintf(Out,"\t%s\t: in BIT",Bptr->name);
! 	}
!     }
  
      Bptr=(Model->Outputs)->BITs;
      while(Bptr->next!=NULL){
***************
*** 1403,1410 ****
  	    if (init) (void)fputs(" ;\n",Out);
  	    else init=1;
  	    (void)fprintf(Out,"\t%s\t: out BIT",Bptr->name);
! 	};
!     };
  
      Vptr=(Model->Inputs)->VECTs;
      while(Vptr->next!=NULL){
--- 1403,1410 ----
  	    if (init) (void)fputs(" ;\n",Out);
  	    else init=1;
  	    (void)fprintf(Out,"\t%s\t: out BIT",Bptr->name);
! 	}
!     }
  
      Vptr=(Model->Inputs)->VECTs;
      while(Vptr->next!=NULL){
***************
*** 1413,1419 ****
  	else init=1;
  	if (Vptr->dir) (void)fprintf(Out,"\t%s\t: in BIT_VECTOR(%d to %d)",Vptr->name,Vptr->start,Vptr->end);
  	else (void)fprintf(Out,"\t%s\t: in BIT_VECTOR(%d downto %d)",Vptr->name,Vptr->end,Vptr->start);
!     };
  
      Vptr=(Model->Outputs)->VECTs;
      while(Vptr->next!=NULL){
--- 1413,1419 ----
  	else init=1;
  	if (Vptr->dir) (void)fprintf(Out,"\t%s\t: in BIT_VECTOR(%d to %d)",Vptr->name,Vptr->start,Vptr->end);
  	else (void)fprintf(Out,"\t%s\t: in BIT_VECTOR(%d downto %d)",Vptr->name,Vptr->end,Vptr->start);
!     }
  
      Vptr=(Model->Outputs)->VECTs;
      while(Vptr->next!=NULL){
***************
*** 1423,1432 ****
  	if (Vptr->dir) (void)fprintf(Out,"\t%s\t: out BIT_VECTOR(%d to %d)",Vptr->name,Vptr->start,Vptr->end);
  	else (void)fprintf(Out,"\t%s\t: out BIT_VECTOR(%d downto %d)",Vptr->name,Vptr->end,Vptr->start);
  
!     };
      if (ADDPOWER) {
  	(void)fprintf(Out," ;\n\t%s\t : in BIT;\n\t%s\t : in BIT",VSS,VDD);
!     };
  
      (void)fprintf(Out," );\nEND %s;\n\n\nARCHITECTURE structural_from_SIS OF %s IS\n",Model->name,Model->name);
  
--- 1423,1432 ----
  	if (Vptr->dir) (void)fprintf(Out,"\t%s\t: out BIT_VECTOR(%d to %d)",Vptr->name,Vptr->start,Vptr->end);
  	else (void)fprintf(Out,"\t%s\t: out BIT_VECTOR(%d downto %d)",Vptr->name,Vptr->end,Vptr->start);
  
!     }
      if (ADDPOWER) {
  	(void)fprintf(Out," ;\n\t%s\t : in BIT;\n\t%s\t : in BIT",VSS,VDD);
!     }
  
      (void)fprintf(Out," );\nEND %s;\n\n\nARCHITECTURE structural_from_SIS OF %s IS\n",Model->name,Model->name);
  
***************
*** 1440,1452 ****
  	    (void)fprintf(Out,"\t%s\t: out BIT",Fptr->name);
  	    for(j=1, Fptr++; j<Cptr->npins; j++, Fptr++){
  		(void)fprintf(Out," ;\n\t%s\t: in BIT",Fptr->name);
! 	    };
  	    if (ADDPOWER) {
  		(void)fprintf(Out," ;\n\t%s\t: in BIT ;\n\t%s\t: in BIT",VSS,VDD);
! 	    };
  	    (void)fprintf(Out," );\n  END COMPONENT;\n\n");
! 	};
!     };
  
      Bptr=(Model->Internals)->BITs;
      init=0;
--- 1440,1452 ----
  	    (void)fprintf(Out,"\t%s\t: out BIT",Fptr->name);
  	    for(j=1, Fptr++; j<Cptr->npins; j++, Fptr++){
  		(void)fprintf(Out," ;\n\t%s\t: in BIT",Fptr->name);
! 	    }
  	    if (ADDPOWER) {
  		(void)fprintf(Out," ;\n\t%s\t: in BIT ;\n\t%s\t: in BIT",VSS,VDD);
! 	    }
  	    (void)fprintf(Out," );\n  END COMPONENT;\n\n");
! 	}
!     }
  
      Bptr=(Model->Internals)->BITs;
      init=0;
***************
*** 1453,1459 ****
      while(Bptr->next!=NULL){
  	Bptr=Bptr->next;
  	(void)fprintf(Out,"SIGNAL %s\t: BIT ;\n",Bptr->name);
!     };
  
      (void)fputs("BEGIN\n",Out);
  
--- 1453,1459 ----
      while(Bptr->next!=NULL){
  	Bptr=Bptr->next;
  	(void)fprintf(Out,"SIGNAL %s\t: BIT ;\n",Bptr->name);
!     }
  
      (void)fputs("BEGIN\n",Out);
  
***************
*** 1467,1479 ****
  	Fptr=(Iptr->what)->formals;
  	for(i=0; i<(Iptr->what)->npins-1; i++, Aptr++, Fptr++){
  	    (void)fprintf(Out,"\t%s => %s,\n",Fptr->name,Aptr->name);
! 	};
  	if (ADDPOWER) {
  	    (void)fprintf(Out,"\t%s => %s,\n\t%s => %s,\n\t%s => %s);\n\n",Fptr->name,Aptr->name,VSS,VSS,VDD,VDD);
  	} else {
  	    (void)fprintf(Out,"\t%s => %s);\n\n",Fptr->name,Aptr->name);
! 	};
!     };
      (void)fputs("\nEND structural_from_SIS;\n",Out);
  
  }
--- 1467,1479 ----
  	Fptr=(Iptr->what)->formals;
  	for(i=0; i<(Iptr->what)->npins-1; i++, Aptr++, Fptr++){
  	    (void)fprintf(Out,"\t%s => %s,\n",Fptr->name,Aptr->name);
! 	}
  	if (ADDPOWER) {
  	    (void)fprintf(Out,"\t%s => %s,\n\t%s => %s,\n\t%s => %s);\n\n",Fptr->name,Aptr->name,VSS,VSS,VDD,VDD);
  	} else {
  	    (void)fprintf(Out,"\t%s => %s);\n\n",Fptr->name,Aptr->name);
! 	}
!     }
      (void)fputs("\nEND structural_from_SIS;\n",Out);
  
  }
***************
*** 1507,1513 ****
  	    if ( !strcmp(w,".outputs") ) {
  		GetSignals(LocModel->Outputs);
  	    } else break;
! 	};
      } while (!feof(In));
      
      PrintSignals(LocModel);
--- 1507,1513 ----
  	    if ( !strcmp(w,".outputs") ) {
  		GetSignals(LocModel->Outputs);
  	    } else break;
! 	}
      } while (!feof(In));
      
      PrintSignals(LocModel);
***************
*** 1535,1548 ****
  		    break;
  		} else {
  		    /* SyntaxError("Unknown keyword",w); */
! 		    };
! 	    };
! 	};
  	do GetToken(w); while(*w=='\n');
      } while (!feof(In));
      PrintVST(LocModel); 
      
! };
  
  /* -=[ main ]=-                                     */
  int main(argc,argv)
--- 1535,1548 ----
  		    break;
  		} else {
  		    /* SyntaxError("Unknown keyword",w); */
! 		    }
! 	    }
! 	}
  	do GetToken(w); while(*w=='\n');
      } while (!feof(In));
      PrintVST(LocModel); 
      
! }
  
  /* -=[ main ]=-                                     */
  int main(argc,argv)
***************
*** 1557,1563 ****
      CloseAll();
  
      return 0;
! };
  
  
  
--- 1557,1563 ----
      CloseAll();
  
      return 0;
! }
  
  
  
diff -r -c sis-1.2/cad/include/port.h /projects/sis/sis-devel/common/src/cad/include/port.h
*** sis-1.2/cad/include/port.h	Fri Apr 22 19:02:33 1994
--- /projects/sis/sis-devel/common/src/cad/include/port.h	Thu Sep  1 13:21:06 1994
***************
*** 230,237 ****
--- 230,239 ----
  #define srandom(a) srand48(a)
  #define bzero(a,b) memset(a, 0, b)
  #else
+ #if !defined(__osf__)
  extern VOID_HACK srandom();
  extern long random();
+ #endif
  #endif
  #endif /* _std_h */
  
diff -r -c sis-1.2/espresso/cvrin.c /projects/sis/sis-devel/common/src/espresso/cvrin.c
*** sis-1.2/espresso/cvrin.c	Sat Jun  5 15:54:50 1993
--- /projects/sis/sis-devel/common/src/espresso/cvrin.c	Tue Sep 27 11:31:57 1994
***************
*** 282,289 ****
  	    } else if (equal(word, "p"))
  		(void) fscanf(fp, "%d", &np);
  	    /* .e and .end specify the end of the file */
! 	    else if (equal(word, "e") || equal(word,"end"))
  		return;
  	    /* .kiss turns on the kiss-hack option */
  	    else if (equal(word, "kiss"))
  		kiss = TRUE;
--- 282,297 ----
  	    } else if (equal(word, "p"))
  		(void) fscanf(fp, "%d", &np);
  	    /* .e and .end specify the end of the file */
! 	    else if (equal(word, "e") || equal(word,"end")) {
! 		if (cube.fullset == NULL) {
! 		    /* fatal("unknown PLA size, need .i/.o or .mv");*/
!                 } else if (PLA->F == NULL) {
!                     PLA->F = new_cover(10);
!                     PLA->D = new_cover(10);
!                     PLA->R = new_cover(10);
!                 }
  		return;
+ 	    }
  	    /* .kiss turns on the kiss-hack option */
  	    else if (equal(word, "kiss"))
  		kiss = TRUE;
diff -r -c sis-1.2/espresso/mincov.c /projects/sis/sis-devel/common/src/espresso/mincov.c
*** sis-1.2/espresso/mincov.c	Thu May 14 08:41:05 1992
--- /projects/sis/sis-devel/common/src/espresso/mincov.c	Thu Sep  1 13:07:29 1994
***************
*** 16,24 ****
  #define USE_GIMPEL
  #define USE_INDEP_SET
  
! extern int select_column();
! extern void select_essential();
! extern int verify_cover();
  
  #define fail(why) {\
      (void) fprintf(stderr, "Fatal error: file %s, line %d\n%s\n",\
--- 16,24 ----
  #define USE_GIMPEL
  #define USE_INDEP_SET
  
! static int select_column();
! static void select_essential();
! static int verify_cover();
  
  #define fail(why) {\
      (void) fprintf(stderr, "Fatal error: file %s, line %d\n%s\n",\
diff -r -c sis-1.2/espresso/opo.c /projects/sis/sis-devel/common/src/espresso/opo.c
*** sis-1.2/espresso/opo.c	Thu May 14 08:41:03 1992
--- /projects/sis/sis-devel/common/src/espresso/opo.c	Thu Sep  1 13:07:58 1994
***************
*** 59,65 ****
  static int opo_no_make_sparse;
  static int opo_repeated;
  static int opo_exact;
! void minimize();
  
  void phase_assignment(PLA, opo_strategy)
  pPLA PLA;
--- 59,65 ----
  static int opo_no_make_sparse;
  static int opo_repeated;
  static int opo_exact;
! static void minimize();
  
  void phase_assignment(PLA, opo_strategy)
  pPLA PLA;
diff -r -c sis-1.2/espresso/part.c /projects/sis/sis-devel/common/src/espresso/part.c
*** sis-1.2/espresso/part.c	Thu May 14 08:41:05 1992
--- /projects/sis/sis-devel/common/src/espresso/part.c	Thu Sep  1 13:08:32 1994
***************
*** 9,14 ****
--- 9,15 ----
   */
  #include "mincov_int.h"
  
+ static int visit_col();
  
  static void
  copy_row(A, prow)
diff -r -c sis-1.2/jedi/util.h /projects/sis/sis-devel/common/src/jedi/util.h
*** sis-1.2/jedi/util.h	Fri Jul  1 17:48:13 1994
--- /projects/sis/sis-devel/common/src/jedi/util.h	Thu Sep  8 14:01:42 1994
***************
*** 34,40 ****
  /*
   * token holders for parse_line
   */
! char *targv[1000];			/* pointer to tokens */
  int targc;				/* number of tokens */
  
  /*
--- 34,40 ----
  /*
   * token holders for parse_line
   */
! char *targv[5000];			/* pointer to tokens */
  int targc;				/* number of tokens */
  
  /*
diff -r -c sis-1.2/nova/anneal_code.c /projects/sis/sis-devel/common/src/nova/anneal_code.c
*** sis-1.2/nova/anneal_code.c	Fri Apr 22 19:02:21 1994
--- /projects/sis/sis-devel/common/src/nova/anneal_code.c	Thu Sep  1 16:37:18 1994
***************
*** 286,292 ****
  int left,right;
  {
  
!  long divide,random_num;
   double number;
  
     random_num = random();
--- 286,295 ----
  int left,right;
  {
  
!  long divide, random_num;
! #if !defined(__osf__)
!  long random();
! #endif
   double number;
  
     random_num = random();
diff -r -c sis-1.2/nova/decls.h /projects/sis/sis-devel/common/src/nova/decls.h
*** sis-1.2/nova/decls.h	Thu May 14 08:41:13 1992
--- /projects/sis/sis-devel/common/src/nova/decls.h	Wed Jul 20 16:23:04 1994
***************
*** 61,66 ****
--- 61,67 ----
  char temp1[MAXSTRING];
  char temp2[MAXSTRING];
  char temp3[MAXSTRING];
+ char temp33[MAXSTRING];
  char temp4[MAXSTRING];
  char temp5[MAXSTRING];
  char temp6[MAXSTRING];
diff -r -c sis-1.2/nova/exact_mini.c /projects/sis/sis-devel/common/src/nova/exact_mini.c
*** sis-1.2/nova/exact_mini.c	Thu May 14 08:41:14 1992
--- /projects/sis/sis-devel/common/src/nova/exact_mini.c	Wed Jul 20 16:23:06 1994
***************
*** 1,3 ****
--- 1,12 ----
+ /*
+  * Revision Control Information
+  *
+  * $Source$
+  * $Author$
+  * $Revision$
+  * $Date$
+  *
+  */
  /*******************************************************************************
  *   Invokes the minimizer to get the final boolean representation              *
  *   This version uses the espresso-II version#2.0 binary-valued minimizer      *
diff -r -c sis-1.2/nova/exact_output.c /projects/sis/sis-devel/common/src/nova/exact_output.c
*** sis-1.2/nova/exact_output.c	Thu May 14 08:41:15 1992
--- /projects/sis/sis-devel/common/src/nova/exact_output.c	Wed Jul 20 16:23:06 1994
***************
*** 222,228 ****
  	        printf("\nbest_products = %d", best_products);
  	        printf("\nbest_size = %d\n", best_size);
  	        /*printf("\nbest codes for the states found so far");
! 	        show_exbestcode(states,statenum");*/
      
  	        /* analyzes the correlation between the output
  	           covering relations and rotations                 */
--- 222,228 ----
  	        printf("\nbest_products = %d", best_products);
  	        printf("\nbest_size = %d\n", best_size);
  	        /*printf("\nbest codes for the states found so far");
! 	        show_exbestcode(states,statenum);*/
      
  	        /* analyzes the correlation between the output
  	           covering relations and rotations                 */
***************
*** 248,254 ****
  
  	  if (VERBOSE) printf("best_size = %d\n", best_size);
  	  /*printf("\nbest codes for the states found so far");
! 	  show_exbestcode(states,statenum");*/
  
      }
  
--- 248,254 ----
  
  	  if (VERBOSE) printf("best_size = %d\n", best_size);
  	  /*printf("\nbest codes for the states found so far");
! 	  show_exbestcode(states,statenum);*/
  
      }
  
***************
*** 274,280 ****
      if (ISYMB) {
  	for ( i = 0; i < inputnum; i++ ) {
  	    strcpy(inputs[i].exbest_code,inputs[i].exact_code);
! 	}
      }
  
      /* saves the state codes */
--- 274,280 ----
      if (ISYMB) {
  	for ( i = 0; i < inputnum; i++ ) {
  	    strcpy(inputs[i].exbest_code,inputs[i].exact_code);
! }
      }
  
      /* saves the state codes */
***************
*** 282,287 ****
--- 282,291 ----
  	strcpy(states[i].exbest_code,states[i].exact_code);
      }
  
+     /* saves the unminimized cover in temp33 - to fix a bug, july 1994 */
+     sprintf(command,"cp %s %s", temp3, temp33);
+     system(command);
+ 
      /* saves the minimized cover in temp5 */
      sprintf(command,"cp %s %s", temp4, temp5);
      system(command);
***************
*** 308,314 ****
  
  
      /*printf("Codes of the states before the complementation");
!     show_excode(states,statenum");*/
  
      for ( bit = 0; bit < strlen(states[0].exact_code); bit++ ) {
  	if ( states[null_code].exact_code[bit] == ONE) {
--- 312,318 ----
  
  
      /*printf("Codes of the states before the complementation");
!     show_exactcode(states,statenum);*/
  
      for ( bit = 0; bit < strlen(states[0].exact_code); bit++ ) {
  	if ( states[null_code].exact_code[bit] == ONE) {
***************
*** 324,329 ****
      }
  
      /*printf("\nCodes of the states after the complementation");
!     show_excode(states,statenum");*/
  
  }
--- 328,333 ----
      }
  
      /*printf("\nCodes of the states after the complementation");
!     show_exactcode(states,statenum);*/
  
  }
diff -r -c sis-1.2/nova/get_constr.c /projects/sis/sis-devel/common/src/nova/get_constr.c
*** sis-1.2/nova/get_constr.c	Thu May 14 08:41:15 1992
--- /projects/sis/sis-devel/common/src/nova/get_constr.c	Wed Jul 20 16:23:06 1994
***************
*** 30,36 ****
      for (i = 0; i < statenum; i++) zeroutput[i] = 0;
  
      if ((fp = fopen(temp1,"w")) == NULL) {
!         fprintf(stderr,"fopen: can't create temp1\n");    
          exit(-1);
      }
  
--- 30,36 ----
      for (i = 0; i < statenum; i++) zeroutput[i] = 0;
  
      if ((fp = fopen(temp1,"w")) == NULL) {
!         fprintf(stderr,"fopen: can't create %s (temp1)\n", temp1);    
          exit(-1);
      }
  
diff -r -c sis-1.2/nova/input_fsm.c /projects/sis/sis-devel/common/src/nova/input_fsm.c
*** sis-1.2/nova/input_fsm.c	Thu May 14 08:41:15 1992
--- /projects/sis/sis-devel/common/src/nova/input_fsm.c	Wed Jul 20 16:23:07 1994
***************
*** 1,3 ****
--- 1,12 ----
+ /*
+  * Revision Control Information
+  *
+  * $Source$
+  * $Author$
+  * $Revision$
+  * $Date$
+  *
+  */
  #include "nova.h"
  
  /*********************************************************************
diff -r -c sis-1.2/nova/log_mini.c /projects/sis/sis-devel/common/src/nova/log_mini.c
*** sis-1.2/nova/log_mini.c	Thu May 14 08:41:21 1992
--- /projects/sis/sis-devel/common/src/nova/log_mini.c	Wed Jul 20 16:23:08 1994
***************
*** 1,3 ****
--- 1,12 ----
+ /*
+  * Revision Control Information
+  *
+  * $Source$
+  * $Author$
+  * $Revision$
+  * $Date$
+  *
+  */
  
  /*******************************************************************************
  *   Invokes the minimizer to get the final boolean representation              *
diff -r -c sis-1.2/nova/log_output.c /projects/sis/sis-devel/common/src/nova/log_output.c
*** sis-1.2/nova/log_output.c	Thu May 14 08:41:21 1992
--- /projects/sis/sis-devel/common/src/nova/log_output.c	Wed Jul 20 16:23:08 1994
***************
*** 306,311 ****
--- 306,315 ----
  	strcpy(states[i].exbest_code,states[i].code);
      }
  
+     /* saves the unminimized cover in temp33 - to fix a bug, july 1994 */
+     sprintf(command,"cp %s %s", temp3, temp33);
+     system(command);
+ 
      /* saves the minimized cover in temp5 */
      sprintf(command,"cp %s %s", temp4, temp5);
      system(command);
diff -r -c sis-1.2/nova/nova.c /projects/sis/sis-devel/common/src/nova/nova.c
*** sis-1.2/nova/nova.c	Tue Sep 14 10:58:29 1993
--- /projects/sis/sis-devel/common/src/nova/nova.c	Wed Jul 20 16:23:11 1994
***************
*** 1,3 ****
--- 1,12 ----
+ /*
+  * Revision Control Information
+  *
+  * $Source$
+  * $Author$
+  * $Revision$
+  * $Date$
+  *
+  */
  #include "nova.h"
  #include "decls.h"
  
***************
*** 197,203 ****
  
      add_terminals(); /* temp5 copied to esp here */
      if (!ONEHOT) { 
! 	sprintf(command, "sis -o %s -t pla -T blif %s", dc, temp3);
          system(command);
      } else {
  	read_script(esp);
--- 206,214 ----
  
      add_terminals(); /* temp5 copied to esp here */
      if (!ONEHOT) { 
!         /* temp33 contains the best unminimized cover -
!            input of previous version was temp3 my mistake - july 1994 */
!         sprintf(command, "sis -o %s -t pla -T blif %s", dc, temp33);
          system(command);
      } else {
  	read_script(esp);
***************
*** 206,212 ****
          sprintf(command, "rm %s", readscript); system(command);
  	/* or replace esp by temp3 in the else clause */
      }
!     sprintf(command, "rm %s %s %s %s %s", temp1, temp2, temp3, temp4, temp5);
      system(command);
  
      if (!SIS) nova_summ();
--- 217,223 ----
          sprintf(command, "rm %s", readscript); system(command);
  	/* or replace esp by temp3 in the else clause */
      }
!     sprintf(command, "rm %s %s %s %s %s %s", temp1, temp2, temp3, temp33, temp4, temp5);
      system(command);
  
      if (!SIS) nova_summ();
***************
*** 223,229 ****
  	    /* or call sis to get blif from esp as in the above else clause */
          }
  	nova_blif();
! 	sprintf(command, "rm %s %s", dc, blif); system(command);
  	printf("# .end_network\n");
      }
      if (PLA_OUTPUT) {
--- 234,240 ----
  	    /* or call sis to get blif from esp as in the above else clause */
          }
  	nova_blif();
!         sprintf(command, "rm %s %s", dc, blif); system(command);
  	printf("# .end_network\n");
      }
      if (PLA_OUTPUT) {
***************
*** 321,326 ****
--- 332,338 ----
      sprintf(temp1, "%s.temp1", file_name);
      sprintf(temp2, "%s.temp2", file_name);
      sprintf(temp3, "%s.temp3", file_name);
+     sprintf(temp33, "%s.temp33", file_name);
      sprintf(temp4, "%s.temp4", file_name);
      sprintf(temp5, "%s.temp5", file_name);
      sprintf(temp6, "%s.temp6", file_name);
diff -r -c sis-1.2/nova/nova.h /projects/sis/sis-devel/common/src/nova/nova.h
*** sis-1.2/nova/nova.h	Thu May 14 08:41:22 1992
--- /projects/sis/sis-devel/common/src/nova/nova.h	Wed Jul 20 16:23:11 1994
***************
*** 201,211 ****
  extern char zero_state[MAXSTRING];       /* user given state to code to zero */
  extern char init_state[MAXSTRING];       /* user given initial state         */
  extern char init_code[MAXSTRING];        /* code assigned to the init. state */
! extern char file_name[MAXSTRING];         /* name of the input file           */
  extern char sh_filename[MAXSTRING];      /* name of the input file           */
  extern char temp1[MAXSTRING];            /* name of the temp1 file           */
  extern char temp2[MAXSTRING];            /* name of the temp2 file           */
  extern char temp3[MAXSTRING];            /* name of the temp3 file           */
  extern char temp4[MAXSTRING];            /* name of the temp4 file           */
  extern char temp5[MAXSTRING];            /* name of the temp5 file           */
  extern char temp6[MAXSTRING];            /* name of the temp6 file           */
--- 201,212 ----
  extern char zero_state[MAXSTRING];       /* user given state to code to zero */
  extern char init_state[MAXSTRING];       /* user given initial state         */
  extern char init_code[MAXSTRING];        /* code assigned to the init. state */
! extern char file_name[MAXSTRING];         /* name of the input file          */
  extern char sh_filename[MAXSTRING];      /* name of the input file           */
  extern char temp1[MAXSTRING];            /* name of the temp1 file           */
  extern char temp2[MAXSTRING];            /* name of the temp2 file           */
  extern char temp3[MAXSTRING];            /* name of the temp3 file           */
+ extern char temp33[MAXSTRING];           /* name of the temp33 file          */
  extern char temp4[MAXSTRING];            /* name of the temp4 file           */
  extern char temp5[MAXSTRING];            /* name of the temp5 file           */
  extern char temp6[MAXSTRING];            /* name of the temp6 file           */
diff -r -c sis-1.2/nova/oldport.h /projects/sis/sis-devel/common/src/nova/oldport.h
*** sis-1.2/nova/oldport.h	Fri Apr 22 19:02:25 1994
--- /projects/sis/sis-devel/common/src/nova/oldport.h	Wed Jul 20 16:23:11 1994
***************
*** 7,12 ****
--- 7,21 ----
   * $Date$
   *
   */
+ /*
+  * Revision Control Information
+  *
+  * $Source$
+  * $Author$
+  * $Revision$
+  * $Date$
+  *
+  */
  #ifndef PORT_H
  #define PORT_H
  
diff -r -c sis-1.2/options/options.c /projects/sis/sis-devel/common/src/options/options.c
*** sis-1.2/options/options.c	Fri Jul 15 15:53:44 1994
--- /projects/sis/sis-devel/common/src/options/options.c	Thu Sep  1 16:30:07 1994
***************
*** 12,17 ****
--- 12,27 ----
  #include "utility.h"
  #include "options.h"
  
+ static int doUnivOption();
+ static void usageSummary();
+ static void usageDetailed();
+ static void formatInit();
+ static void formatFlush();
+ static void formatString();
+ static void formatChar();
+ static void formatTab();
+ static void formatOptChoice();
+ 
  #ifndef MM_TRACE
  #define MM_PAD          0
  #define MM_TRACE        1
***************
*** 290,296 ****
  				    inGroup = 0;			\
  				}
  
! static usageSummary()
  {
      struct optGroup *optGrpPtr;
      optionStruct *optPtr;
--- 300,307 ----
  				    inGroup = 0;			\
  				}
  
! static void
! usageSummary()
  {
      struct optGroup *optGrpPtr;
      optionStruct *optPtr;
***************
*** 333,339 ****
      FINISH_OPTION_GROUP();
  }
  
! static usageDetailed()
  {
      struct optGroup *optGrpPtr;
      optionStruct *optPtr;
--- 344,351 ----
      FINISH_OPTION_GROUP();
  }
  
! static void
! usageDetailed()
  {
      struct optGroup *optGrpPtr;
      optionStruct *optPtr;
***************
*** 372,378 ****
  static int indent;
  static char lineBuffer[LINEWIDTH];
  
! static formatInit(contIndent)
  int contIndent;
  {
      if (curColumn > 0) formatFlush();
--- 384,391 ----
  static int indent;
  static char lineBuffer[LINEWIDTH];
  
! static void
! formatInit(contIndent)
  int contIndent;
  {
      if (curColumn > 0) formatFlush();
***************
*** 379,385 ****
      indent = contIndent;
  }
  
! static formatFlush()
  {
      int i;
  
--- 392,399 ----
      indent = contIndent;
  }
  
! static void
! formatFlush()
  {
      int i;
  
***************
*** 393,405 ****
      curColumn = 0;
  }
  
! static formatString(string)
  char *string;
  {
      while (*string != '\0') formatChar(*string++);
  }
  
! static formatChar(ch)
  int ch;
  {
      if (ch == '\n') {
--- 407,421 ----
      curColumn = 0;
  }
  
! static void
! formatString(string)
  char *string;
  {
      while (*string != '\0') formatChar(*string++);
  }
  
! static void
! formatChar(ch)
  int ch;
  {
      if (ch == '\n') {
***************
*** 431,437 ****
      }
  }
  
! static formatTab(position)
  int position;
  {
      if (position >= LINEWIDTH) position = LINEWIDTH - 1;
--- 447,454 ----
      }
  }
  
! static void
! formatTab(position)
  int position;
  {
      if (position >= LINEWIDTH) position = LINEWIDTH - 1;
***************
*** 439,445 ****
      while (curColumn < position) formatChar(' ');
  }
  
! static formatOptChoice(optChars)
  char *optChars;
  {
      int firstFlag = 1;
--- 456,463 ----
      while (curColumn < position) formatChar(' ');
  }
  
! static void
! formatOptChoice(optChars)
  char *optChars;
  {
      int firstFlag = 1;
diff -r -c sis-1.2/port/port.h /projects/sis/sis-devel/common/src/port/port.h
*** sis-1.2/port/port.h	Fri Apr 22 19:02:33 1994
--- /projects/sis/sis-devel/common/src/port/port.h	Thu Sep  1 13:21:06 1994
***************
*** 230,237 ****
--- 230,239 ----
  #define srandom(a) srand48(a)
  #define bzero(a,b) memset(a, 0, b)
  #else
+ #if !defined(__osf__)
  extern VOID_HACK srandom();
  extern long random();
+ #endif
  #endif
  #endif /* _std_h */
  
diff -r -c sis-1.2/sis/array/array.c /projects/sis/sis-devel/common/src/sis/array/array.c
*** sis-1.2/sis/array/array.c	Fri Jul 15 15:56:24 1994
--- /projects/sis/sis-devel/common/src/sis/array/array.c	Thu Aug  4 08:05:27 1994
***************
*** 39,44 ****
--- 39,45 ----
  array_free(array)
  array_t *array;
  {
+     if (array == NIL(array_t)) return;
      if (array->index >= 0) array_abort(array,4);
      FREE(array->space);
      FREE(array);
diff -r -c sis-1.2/sis/astg/astg_int.h /projects/sis/sis-devel/common/src/sis/astg/astg_int.h
*** sis-1.2/sis/astg/astg_int.h	Fri Jul 15 15:56:35 1994
--- /projects/sis/sis-devel/common/src/sis/astg/astg_int.h	Tue Sep  6 13:45:52 1994
***************
*** 135,141 ****
  astg_place	*astg_new_place ARGS((astg_graph *, char *, void *));
  void		 astg_delete_place ARGS((astg_place *));
  char		*astg_place_name ARGS((astg_place *));
! astg_place	*astg_find_place ARGS((astg_graph *, char *, astg_bool));;
  astg_bool	 astg_boring_place ARGS((astg_place *));
  astg_bool	 astg_get_marked ARGS((astg_marking *, astg_place *));
  void		 astg_set_marked ARGS((astg_marking *, astg_place *, astg_bool));
--- 135,141 ----
  astg_place	*astg_new_place ARGS((astg_graph *, char *, void *));
  void		 astg_delete_place ARGS((astg_place *));
  char		*astg_place_name ARGS((astg_place *));
! astg_place	*astg_find_place ARGS((astg_graph *, char *, astg_bool));
  astg_bool	 astg_boring_place ARGS((astg_place *));
  astg_bool	 astg_get_marked ARGS((astg_marking *, astg_place *));
  void		 astg_set_marked ARGS((astg_marking *, astg_place *, astg_bool));
diff -r -c sis-1.2/sis/astg/bwd_com.c /projects/sis/sis-devel/common/src/sis/astg/bwd_com.c
*** sis-1.2/sis/astg/bwd_com.c	Fri Jul 15 15:56:43 1994
--- /projects/sis/sis-devel/common/src/sis/astg/bwd_com.c	Mon Sep 19 20:07:31 1994
***************
*** 706,711 ****
--- 706,713 ----
    min_del_t delay, *delay_p;
    st_generator *pigen, *pogen;
    astg_graph *astg;
+   lsGen gen;
+   node_t *node;
  
    tol = 0;
    default_del = 0;
***************
*** 852,857 ****
--- 854,866 ----
  	  bwd_slow_down (*network_p, hazard_list, slowed_amounts, external_del, tol,
  			 default_del, min_delay_factor, shortest_path, iterate, do_slow);
    }
+ 
+   /* reset arrival times on PIs */
+   foreach_primary_input (*network_p, gen, node) {
+         delay_set_parameter (node, DELAY_ARRIVAL_RISE, (double) -1);
+         delay_set_parameter (node, DELAY_ARRIVAL_FALL, (double) -1);
+   }
+ 
    /* write back the (possibly updated) external delay table */
    if (update && filename != NIL(char)) {
      file = com_open_file (filename,"w",NULL,0);
diff -r -c sis-1.2/sis/astg/bwd_hazard.c /projects/sis/sis-devel/common/src/sis/astg/bwd_hazard.c
*** sis-1.2/sis/astg/bwd_hazard.c	Fri Jul 15 15:56:44 1994
--- /projects/sis/sis-devel/common/src/sis/astg/bwd_hazard.c	Wed Jul 27 00:47:12 1994
***************
*** 145,153 ****
  {
  	new->dir1 = old->dir1;
  	new->dir2 = old->dir2;
- 	new->on = old->on;
  	new->s1 = util_strsav (old->s1);
  	new->s2 = util_strsav (old->s2);
  }
  
  void
--- 145,156 ----
  {
  	new->dir1 = old->dir1;
  	new->dir2 = old->dir2;
  	new->s1 = util_strsav (old->s1);
  	new->s2 = util_strsav (old->s2);
+ 	new->on_cb1 = set_save (old->on_cb1);
+ 	new->off_cb1 = set_save (old->off_cb1);
+ 	new->on_cb2 = set_save (old->on_cb2);
+ 	new->off_cb2 = set_save (old->off_cb2);
  }
  
  void
***************
*** 156,161 ****
--- 159,168 ----
  {
  	FREE (haz->s1);
  	FREE (haz->s2);
+ 	set_free (haz->on_cb1);
+ 	set_free (haz->off_cb1);
+ 	set_free (haz->on_cb2);
+ 	set_free (haz->off_cb2);
  }
  
  
***************
*** 164,171 ****
  same_hazard (t1, t2)
  hazard_t *t1, *t2;
  {
!   if (t1->on != t2->on ||
! 	t1->dir1 != t2->dir1 || 
  	t1->dir2 != t2->dir2) {
  	return 0;
    }
--- 171,177 ----
  same_hazard (t1, t2)
  hazard_t *t1, *t2;
  {
!   if (t1->dir1 != t2->dir1 || 
  	t1->dir2 != t2->dir2) {
  	return 0;
    }
***************
*** 175,180 ****
--- 181,198 ----
    if (strcmp (t1->s2, t2->s2)) {
      return 0;
    }
+   if (setp_equal (t1->on_cb1, t2->on_cb1)) {
+     return 0;
+   }
+   if (setp_equal (t1->off_cb1, t2->off_cb1)) {
+     return 0;
+   }
+   if (setp_equal (t1->on_cb2, t2->on_cb2)) {
+     return 0;
+   }
+   if (setp_equal (t1->off_cb2, t2->on_cb2)) {
+     return 0;
+   }
    return 1;
  }
  
***************
*** 465,470 ****
--- 483,492 ----
  			hazard.s2 = node_long_name (array_fetch (node_t *, fanin, var2));
  			hazard.dir1 = dir1;
  			hazard.dir2 = dir2;
+ 			hazard.on_cb1 = on_cube1;
+ 			hazard.off_cb1 = off_cube1;
+ 			hazard.on_cb2 = on_cube2;
+ 			hazard.off_cb2 = off_cube2;
  			for (i = 0; i < array_n (hazards); i++) {
  			  hazard1 = array_fetch (hazard_t, hazards, i);
  			  if (same_hazard (&hazard, &hazard1)) {
***************
*** 475,480 ****
--- 497,506 ----
  			if (i >= array_n (hazards)) {
  			  hazard.s1 = util_strsav (hazard.s1);
  			  hazard.s2 = util_strsav (hazard.s2);
+ 			  hazard.on_cb1 = set_save (hazard.on_cb1);
+ 			  hazard.off_cb1 = set_save (hazard.off_cb1);
+ 			  hazard.on_cb2 = set_save (hazard.on_cb2);
+ 			  hazard.off_cb2 = set_save (hazard.off_cb2);
  			  array_insert_last (hazard_t, hazards, hazard);
  			  if (astg_debug_flag > 0) {
  				fprintf (sisout, 
diff -r -c sis-1.2/sis/astg/bwd_lp.c /projects/sis/sis-devel/common/src/sis/astg/bwd_lp.c
*** sis-1.2/sis/astg/bwd_lp.c	Fri Aug  6 15:50:16 1993
--- /projects/sis/sis-devel/common/src/sis/astg/bwd_lp.c	Mon Sep 19 20:06:22 1994
***************
*** 370,376 ****
  	}
  
  	node = node_get_fanin (po, 0);
- 	assert (BWD(node)->arrival >= 0);
  	return BWD(node)->arrival;
  }
  
--- 370,375 ----
***************
*** 482,487 ****
--- 481,489 ----
  	st_free_table (subnet2);
  	if (astg_debug_flag > 2) {
  		fprintf (sisout, "d1 %f d2 %f\n", d1, d2);
+ 	}
+ 	if (d1 < 0 || d2 < 0) {
+ 		return -1;
  	}
  	return d2 - d1;
  }
diff -r -c sis-1.2/sis/astg/bwd_slow.c /projects/sis/sis-devel/common/src/sis/astg/bwd_slow.c
*** sis-1.2/sis/astg/bwd_slow.c	Thu Aug  5 17:06:02 1993
--- /projects/sis/sis-devel/common/src/sis/astg/bwd_slow.c	Fri Oct 28 14:00:42 1994
***************
*** 609,615 ****
  		} while (! iterate && curr_slow < max_diff + tol);
        }
      } while (failed);
- 			  *slowed = 0.0;
  
      array_free (hazards);
    }
--- 609,614 ----
diff -r -c sis-1.2/sis/atpg/atpg.h /projects/sis/sis-devel/common/src/sis/atpg/atpg.h
*** sis-1.2/sis/atpg/atpg.h	Fri Jul 15 16:00:24 1994
--- /projects/sis/sis-devel/common/src/sis/atpg/atpg.h	Fri Sep 30 10:20:40 1994
***************
*** 114,119 ****
--- 114,120 ----
      bool print_sequences;
      char *real_filename;
      FILE *fp;
+     bool force_comb;
  } atpg_options_t;
  
  typedef struct {
diff -r -c sis-1.2/sis/atpg/atpg_gen_test.c /projects/sis/sis-devel/common/src/sis/atpg/atpg_gen_test.c
*** sis-1.2/sis/atpg/atpg_gen_test.c	Fri Jul 15 16:00:29 1994
--- /projects/sis/sis-devel/common/src/sis/atpg/atpg_gen_test.c	Thu Sep  1 12:24:43 1994
***************
*** 254,262 ****
  	n_old_vectors = 0;
      } else {
  	bdd_key = convert_bdd_to_int(seq_info->start_state_used);
! 	assert(st_lookup(seq_info->state_sequence_table, (char **) bdd_key, (char **) &sequence_list));
  	assert(lsLength(sequence_list) > 0);
! 	(void) lsFirstItem(sequence_list, &sequence_start, 0);
  	old_vectors = sequence_start->vectors;
  	n_old_vectors = array_n(old_vectors);
  	create_just_sequence(seq_info, n_just_vectors + 1, old_vectors, info->n_real_pi);
--- 254,262 ----
  	n_old_vectors = 0;
      } else {
  	bdd_key = convert_bdd_to_int(seq_info->start_state_used);
! 	assert(st_lookup(seq_info->state_sequence_table, (char *) bdd_key, (char **) &sequence_list));
  	assert(lsLength(sequence_list) > 0);
! 	(void) lsFirstItem(sequence_list, (lsGeneric *) &sequence_start, 0);
  	old_vectors = sequence_start->vectors;
  	n_old_vectors = array_n(old_vectors);
  	create_just_sequence(seq_info, n_just_vectors + 1, old_vectors, info->n_real_pi);
***************
*** 336,343 ****
  	}
      }
      if (n_old_vectors && fault->is_covered) {
! 	assert(st_delete_int(seq_info->state_sequence_table, (char **) &bdd_key, (char **) &sequence_list));
! 	(void) lsDelBegin(sequence_list, &sequence_start);
  	assert(st_delete(info->sequence_table, (char **) &sequence_start, NIL(char *)));
  	if (lsLength(sequence_list) == 0) {
  	    new_start_states = bdd_and(seq_info->start_states, 
--- 336,343 ----
  	}
      }
      if (n_old_vectors && fault->is_covered) {
! 	assert(st_delete_int(seq_info->state_sequence_table, &bdd_key, (char **) &sequence_list));
! 	(void) lsDelBegin(sequence_list, (lsGeneric *) &sequence_start);
  	assert(st_delete(info->sequence_table, (char **) &sequence_start, NIL(char *)));
  	if (lsLength(sequence_list) == 0) {
  	    new_start_states = bdd_and(seq_info->start_states, 
***************
*** 395,403 ****
  			   seq_info->product_range_data->init_state_fn)) {
  		internal_state_used = TRUE;
  		key = convert_product_bdd_to_key(info, seq_info, start_state_used);
! 		assert(st_lookup(seq_info->state_sequence_table, (char **) key, (char **) &sequence_list));
  		assert(lsLength(sequence_list) > 0);
! 		(void) lsFirstItem(sequence_list, &sequence_start, 0);
  		old_vectors = sequence_start->vectors;
  		n_old_vectors = array_n(old_vectors);
      		if (n_old_vectors > array_n(just_sequence)) {
--- 395,403 ----
  			   seq_info->product_range_data->init_state_fn)) {
  		internal_state_used = TRUE;
  		key = convert_product_bdd_to_key(info, seq_info, start_state_used);
! 		assert(st_lookup(seq_info->state_sequence_table, (char *) key, (char **) &sequence_list));
  		assert(lsLength(sequence_list) > 0);
! 		(void) lsFirstItem(sequence_list, (lsGeneric *) &sequence_start, 0);
  		old_vectors = sequence_start->vectors;
  		n_old_vectors = array_n(old_vectors);
      		if (n_old_vectors > array_n(just_sequence)) {
***************
*** 430,437 ****
  	    fault->is_covered = TRUE;
  	    fault->status = TESTED;
  	    if (internal_state_used) {
! 		assert(st_delete_int(seq_info->state_sequence_table, (char **) &key, (char **) &sequence_list));
! 		(void) lsDelBegin(sequence_list, &sequence_start);
  		assert(st_delete(info->sequence_table, (char **) &sequence_start, NIL(char *)));
  		if (lsLength(sequence_list) == 0) {
  		    new_start_states = bdd_and(seq_info->product_start_states, 
--- 430,437 ----
  	    fault->is_covered = TRUE;
  	    fault->status = TESTED;
  	    if (internal_state_used) {
! 		assert(st_delete_int(seq_info->state_sequence_table, &key, (char **) &sequence_list));
! 		(void) lsDelBegin(sequence_list, (lsGeneric *) &sequence_start);
  		assert(st_delete(info->sequence_table, (char **) &sequence_start, NIL(char *)));
  		if (lsLength(sequence_list) == 0) {
  		    new_start_states = bdd_and(seq_info->product_start_states, 
diff -r -c sis-1.2/sis/atpg/atpg_init.c /projects/sis/sis-devel/common/src/sis/atpg/atpg_init.c
*** sis-1.2/sis/atpg/atpg_init.c	Fri Jul 15 16:00:30 1994
--- /projects/sis/sis-devel/common/src/sis/atpg/atpg_init.c	Fri Sep 30 10:20:47 1994
***************
*** 53,62 ****
      atpg_opt->prop_rtg_depth = 20;
      atpg_opt->n_random_prop_iter = 1;
      atpg_opt->print_sequences = FALSE;
  
      util_getopt_reset();
!     while ((c = util_getopt(argc, argv, "d:DfFhn:qrRptT:v:y:z:")) != EOF) {
  	switch (c) {
  	    case 'd':
  		atpg_opt->rtg_depth = atoi(util_optarg);
  		break;
--- 53,66 ----
      atpg_opt->prop_rtg_depth = 20;
      atpg_opt->n_random_prop_iter = 1;
      atpg_opt->print_sequences = FALSE;
+     atpg_opt->force_comb = FALSE;
  
      util_getopt_reset();
!     while ((c = util_getopt(argc, argv, "cd:DfFhn:qrRptT:v:y:z:")) != EOF) {
  	switch (c) {
+ 	    case 'c':
+ 		atpg_opt->force_comb = TRUE;
+ 		break;
  	    case 'd':
  		atpg_opt->rtg_depth = atoi(util_optarg);
  		break;
diff -r -c sis-1.2/sis/atpg/atpg_seq.c /projects/sis/sis-devel/common/src/sis/atpg/atpg_seq.c
*** sis-1.2/sis/atpg/atpg_seq.c	Fri Jul 15 16:00:32 1994
--- /projects/sis/sis-devel/common/src/sis/atpg/atpg_seq.c	Thu Sep  1 12:28:57 1994
***************
*** 63,69 ****
      i = 0;
      foreach_latch(seq_info->network_copy, gen, l) {
  	pi = latch_get_output(l);
! 	assert(st_lookup_int(pi_ordering, (char *) pi, (char **) &position));
  	array_insert(int, seq_info->latch_to_pi_ordering, i ++, position);
      }
  
--- 63,69 ----
      i = 0;
      foreach_latch(seq_info->network_copy, gen, l) {
  	pi = latch_get_output(l);
! 	assert(st_lookup_int(pi_ordering, (char *) pi, &position));
  	array_insert(int, seq_info->latch_to_pi_ordering, i ++, position);
      }
  
***************
*** 106,112 ****
  	i = 0;
  	foreach_latch(seq_info->product_network, gen, l) {
  	    pi = latch_get_output(l);
! 	    assert(st_lookup_int(product_pi_ordering, (char *) pi, (char **) &position));
  	    if (i < info->n_latch) {
  	    	array_insert(int, seq_info->latch_to_product_pi_ordering, i ++, position);
  	    }
--- 106,112 ----
  	i = 0;
  	foreach_latch(seq_info->product_network, gen, l) {
  	    pi = latch_get_output(l);
! 	    assert(st_lookup_int(product_pi_ordering, (char *) pi, &position));
  	    if (i < info->n_latch) {
  	    	array_insert(int, seq_info->latch_to_product_pi_ordering, i ++, position);
  	    }
***************
*** 304,310 ****
      excite_node = node_constant(1);
      foreach_primary_input(info->network, gen, pi) {
  	if ( (latch_from_node(pi)) != NIL(latch_t) ) {
! 	    assert(st_lookup_int(table, (char *) pi, (char **) &value));
  	    pi_in_copy = network_find_node(network_copy, pi->name);
  	    switch (value) {
  		case 0:
--- 304,310 ----
      excite_node = node_constant(1);
      foreach_primary_input(info->network, gen, pi) {
  	if ( (latch_from_node(pi)) != NIL(latch_t) ) {
! 	    assert(st_lookup_int(table, (char *) pi, &value));
  	    pi_in_copy = network_find_node(network_copy, pi->name);
  	    switch (value) {
  		case 0:
***************
*** 345,351 ****
      minterm = seq_get_one_minterm(range_data->manager,
                                       already_justified, seq_info->var_table);
      justified_excite_state = bdd_smooth(minterm, seq_info->real_pi_bdds);
!     assert(st_lookup(seq_info->just_sequence_table, convert_bdd_to_int(justified_excite_state), &old_just_sequence));
      seq_length = array_n(old_just_sequence);
      if (ATPG_DEBUG) {
  	if (array_n(old_just_sequence) == 0) 
--- 345,353 ----
      minterm = seq_get_one_minterm(range_data->manager,
                                       already_justified, seq_info->var_table);
      justified_excite_state = bdd_smooth(minterm, seq_info->real_pi_bdds);
!     assert(st_lookup(seq_info->just_sequence_table,
!                      (char *) convert_bdd_to_int(justified_excite_state),
!                      (char **) &old_just_sequence));
      seq_length = array_n(old_just_sequence);
      if (ATPG_DEBUG) {
  	if (array_n(old_just_sequence) == 0) 
***************
*** 562,568 ****
  	}
      }
      if (save_sequence_for_reuse) {
!     	st_insert(table, (char *) key, sequence_for_reuse);
      }
  }
  
--- 564,570 ----
  	}
      }
      if (save_sequence_for_reuse) {
!     	st_insert(table, (char *) key, (char *) sequence_for_reuse);
      }
  }
  
***************
*** 577,583 ****
      int i, j, seq_length;
      unsigned *vector, *old_vector;
  
!     assert(st_lookup(seq_info->prop_sequence_table, key, &old_prop_sequence));
      if (old_prop_sequence == NIL(array_t)) return 0;
      seq_length = array_n(old_prop_sequence);
      for (i = seq_length; i -- ; ) {
--- 579,586 ----
      int i, j, seq_length;
      unsigned *vector, *old_vector;
  
!     assert(st_lookup(seq_info->prop_sequence_table, (char *) key,
!                      (char **) &old_prop_sequence));
      if (old_prop_sequence == NIL(array_t)) return 0;
      seq_length = array_n(old_prop_sequence);
      for (i = seq_length; i -- ; ) {
***************
*** 603,609 ****
      n_prop_vectors = traverse_product_machine(info, seq_info, init_state, TRUE);
      if (n_prop_vectors == 0) {
  	key = derive_prop_key(seq_info);
!     	st_insert(seq_info->prop_sequence_table, (char *) key, NIL(array_t));
      }
      bdd_free(init_state);
      return n_prop_vectors;
--- 606,612 ----
      n_prop_vectors = traverse_product_machine(info, seq_info, init_state, TRUE);
      if (n_prop_vectors == 0) {
  	key = derive_prop_key(seq_info);
!     	st_insert(seq_info->prop_sequence_table, (char *) key, NIL(char));
      }
      bdd_free(init_state);
      return n_prop_vectors;
diff -r -c sis-1.2/sis/atpg/atpg_seq_util.c /projects/sis/sis-devel/common/src/sis/atpg/atpg_seq_util.c
*** sis-1.2/sis/atpg/atpg_seq_util.c	Fri Jul 15 16:00:32 1994
--- /projects/sis/sis-devel/common/src/sis/atpg/atpg_seq_util.c	Thu Sep  1 12:30:05 1994
***************
*** 37,43 ****
      int index;
  
      var_names = array_alloc(char *, st_count(leaves));
!     st_foreach_item_int(leaves, gen, (char **) &node, (char **) &index) {
  	array_insert(char *, var_names, index, node->name);
      }
      result = ntbdd_bdd_single_to_network(fn, "bdd_out", var_names);
--- 37,43 ----
      int index;
  
      var_names = array_alloc(char *, st_count(leaves));
!     st_foreach_item_int(leaves, gen, (char **) &node, &index) {
  	array_insert(char *, var_names, index, node->name);
      }
      result = ntbdd_bdd_single_to_network(fn, "bdd_out", var_names);
***************
*** 114,120 ****
    st_generator *gen;
  
    pi_to_var_table = st_init_table(st_ptrcmp, st_ptrhash);
!   st_foreach_item_int(info->pi_ordering, gen, (char **) &pi, (char **) &index) {
      var = ntbdd_node_to_local_bdd(pi, manager,  info->pi_ordering);
      st_insert(pi_to_var_table, (char *) pi, (char *) var);
    }
--- 114,120 ----
    st_generator *gen;
  
    pi_to_var_table = st_init_table(st_ptrcmp, st_ptrhash);
!   st_foreach_item_int(info->pi_ordering, gen, (char **) &pi, &index) {
      var = ntbdd_node_to_local_bdd(pi, manager,  info->pi_ordering);
      st_insert(pi_to_var_table, (char *) pi, (char *) var);
    }
***************
*** 169,175 ****
      (void) bdd_gen_free(gen);
  
      for (i = 0; i < n_lits; i++) {
!         if (! st_lookup(vars, (char *) i, NIL(char **))) {
              assert(lits[i] == 2);
              continue;
          }
--- 169,175 ----
      (void) bdd_gen_free(gen);
  
      for (i = 0; i < n_lits; i++) {
!         if (! st_lookup(vars, (char *) i, NIL(char *))) {
              assert(lits[i] == 2);
              continue;
          }
diff -r -c sis-1.2/sis/atpg/com_atpg.c /projects/sis/sis-devel/common/src/sis/atpg/com_atpg.c
*** sis-1.2/sis/atpg/com_atpg.c	Fri Jul 15 16:00:34 1994
--- /projects/sis/sis-devel/common/src/sis/atpg/com_atpg.c	Thu Sep  1 12:31:05 1994
***************
*** 274,280 ****
                      if (atpg_opt->verbosity > 0) {
                      	fprintf(sisout, "Redundant\n");
                      }
! 		    lsNewEnd(info->redundant_faults, fault, 0);
  		    if (atpg_opt->reverse_fault_sim) {
  		    	fault_info = ALLOC(fault_pattern_t, 1);
      		    	fault_info->node = fault->node;
--- 274,280 ----
                      if (atpg_opt->verbosity > 0) {
                      	fprintf(sisout, "Redundant\n");
                      }
! 		    lsNewEnd(info->redundant_faults, (lsGeneric) fault, 0);
  		    if (atpg_opt->reverse_fault_sim) {
  		    	fault_info = ALLOC(fault_pattern_t, 1);
      		    	fault_info->node = fault->node;
diff -r -c sis-1.2/sis/atpg/com_redund.c /projects/sis/sis-devel/common/src/sis/atpg/com_redund.c
*** sis-1.2/sis/atpg/com_redund.c	Fri Jul 15 16:00:35 1994
--- /projects/sis/sis-devel/common/src/sis/atpg/com_redund.c	Fri Sep 30 10:21:16 1994
***************
*** 113,118 ****
--- 113,126 ----
  	atpg_free_info(info);
  	return 1;
      }
+ 
+     /* This is a hack.  Currently, atpg and hence redundancy removal only
+        works if a single initial state is given.  This forces a sequential
+        circuit to look combinational, so the assumption is that all states
+        are possible initial states.  This means a conservative approximation
+        for sequential redundancy removal. */
+ 
+     if (atpg_opt->force_comb) info->seq = FALSE;
      if (atpg_opt->timeout > 0) {
      	(void) signal(SIGALRM, timeout_handle);
      	(void) alarm((unsigned int) atpg_opt->timeout);
diff -r -c sis-1.2/sis/atpg/com_short_t.c /projects/sis/sis-devel/common/src/sis/atpg/com_short_t.c
*** sis-1.2/sis/atpg/com_short_t.c	Fri Jul 15 16:00:36 1994
--- /projects/sis/sis-devel/common/src/sis/atpg/com_short_t.c	Thu Sep  1 12:33:38 1994
***************
*** 394,400 ****
                      if (atpg_opt->verbosity > 0) {
                      	fprintf(sisout, "Redundant\n");
                      }
! 		    lsNewEnd(info->redundant_faults, fault, 0);
  		    if (atpg_opt->reverse_fault_sim) {
  		    	fault_info = ALLOC(fault_pattern_t, 1);
      		    	fault_info->node = fault->node;
--- 394,400 ----
                      if (atpg_opt->verbosity > 0) {
                      	fprintf(sisout, "Redundant\n");
                      }
! 		    lsNewEnd(info->redundant_faults, (lsGeneric) fault, 0);
  		    if (atpg_opt->reverse_fault_sim) {
  		    	fault_info = ALLOC(fault_pattern_t, 1);
      		    	fault_info->node = fault->node;
***************
*** 444,450 ****
                      if (atpg_opt->verbosity > 0) {
                      	fprintf(sisout, "Untested\n");
                      }
! 	    	    lsNewEnd(info->final_untested_faults, fault, 0);
  	    	    lsRemoveItem(handle, &data);
  		    break;
  	    	default:
--- 444,450 ----
                      if (atpg_opt->verbosity > 0) {
                      	fprintf(sisout, "Untested\n");
                      }
! 	    	    lsNewEnd(info->final_untested_faults, (lsGeneric) fault, 0);
  	    	    lsRemoveItem(handle, &data);
  		    break;
  	    	default:
***************
*** 479,485 ****
                      if (atpg_opt->verbosity > 0) {
                      	fprintf(sisout, "Redundant\n");
                      }
! 		    lsNewEnd(info->redundant_faults, fault, 0);
  		    if (atpg_opt->reverse_fault_sim) {
  		    	fault_info = ALLOC(fault_pattern_t, 1);
      		    	fault_info->node = fault->node;
--- 479,485 ----
                      if (atpg_opt->verbosity > 0) {
                      	fprintf(sisout, "Redundant\n");
                      }
! 		    lsNewEnd(info->redundant_faults, (lsGeneric) fault, 0);
  		    if (atpg_opt->reverse_fault_sim) {
  		    	fault_info = ALLOC(fault_pattern_t, 1);
      		    	fault_info->node = fault->node;
***************
*** 590,600 ****
  	    /* final_state == reset_state */
  	    return;
      	} else {
! 	    lsNewBegin(sequence_list, test_sequence, 0);
  	}
      } else {
  	sequence_list = lsCreate();
! 	lsNewBegin(sequence_list, test_sequence, 0);
  	st_insert(state_sequence_table, (char *) key, (char *) sequence_list);
  	new_state = convert_state_to_bdd(seq_info, good_state);
  	new_start_states = bdd_or(seq_info->start_states, new_state, 1, 1);
--- 590,600 ----
  	    /* final_state == reset_state */
  	    return;
      	} else {
! 	    lsNewBegin(sequence_list, (lsGeneric) test_sequence, 0);
  	}
      } else {
  	sequence_list = lsCreate();
! 	lsNewBegin(sequence_list, (lsGeneric) test_sequence, 0);
  	st_insert(state_sequence_table, (char *) key, (char *) sequence_list);
  	new_state = convert_state_to_bdd(seq_info, good_state);
  	new_start_states = bdd_or(seq_info->start_states, new_state, 1, 1);
***************
*** 635,645 ****
  	    /* final_state == reset_state */
  	    return;
      	} else {
! 	    lsNewBegin(sequence_list, test_sequence, 0);
  	}
      } else {
  	sequence_list = lsCreate();
! 	lsNewBegin(sequence_list, test_sequence, 0);
  	st_insert(state_sequence_table, (char *) key, (char *) sequence_list);
  	new_state = convert_states_to_product_bdd(seq_info, good_state, good_state);
  	new_start_states = bdd_or(seq_info->product_start_states, new_state, 1, 1);
--- 635,645 ----
  	    /* final_state == reset_state */
  	    return;
      	} else {
! 	    lsNewBegin(sequence_list, (lsGeneric) test_sequence, 0);
  	}
      } else {
  	sequence_list = lsCreate();
! 	lsNewBegin(sequence_list, (lsGeneric) test_sequence, 0);
  	st_insert(state_sequence_table, (char *) key, (char *) sequence_list);
  	new_state = convert_states_to_product_bdd(seq_info, good_state, good_state);
  	new_start_states = bdd_or(seq_info->product_start_states, new_state, 1, 1);
diff -r -c sis-1.2/sis/bdd_cmu/Makefile /projects/sis/sis-devel/common/src/sis/bdd_cmu/Makefile
*** sis-1.2/sis/bdd_cmu/Makefile	Fri Jul  8 18:48:31 1994
--- /projects/sis/sis-devel/common/src/sis/bdd_cmu/Makefile	Tue Aug 30 11:38:58 1994
***************
*** 1,6 ****
  # This Makefile is used to build the libraries of all the package in bdd_cmu
  
! SIS = /projects/sis/sis-devel/common/src/sis
  CURRENT = $(SIS)/bdd_cmu
  
  P = bdd
--- 1,6 ----
  # This Makefile is used to build the libraries of all the package in bdd_cmu
  
! SIS = $(PWD)/..
  CURRENT = $(SIS)/bdd_cmu
  
  P = bdd
diff -r -c sis-1.2/sis/command/filec.c /projects/sis/sis-devel/common/src/sis/command/filec.c
*** sis-1.2/sis/command/filec.c	Tue Jul 12 10:23:55 1994
--- /projects/sis/sis-devel/common/src/sis/command/filec.c	Thu Sep 22 19:45:28 1994
***************
*** 7,17 ****
   * $Date: 1993/07/03 16:25:50 $
   *
   */
- #include <sgtty.h>
  #include <sys/types.h>      /* Part of util.h if PORT_H is not defined */
  			    /* Still needs to be included for sun4 compile */
  #include <sys/dir.h>
  #include "sis.h"
  #include "com_int.h"
  
  #if defined(_IBMR2)
--- 7,21 ----
   * $Date: 1993/07/03 16:25:50 $
   *
   */
  #include <sys/types.h>      /* Part of util.h if PORT_H is not defined */
  			    /* Still needs to be included for sun4 compile */
  #include <sys/dir.h>
  #include "sis.h"
+ #ifdef _POSIX_SOURCE
+ #include <sys/termio.h>
+ #else
+ #include <sgtty.h>
+ #endif
  #include "com_int.h"
  
  #if defined(_IBMR2)
***************
*** 19,38 ****
  #endif
  
  #define ESC	'\033'
  #define BEEP	'\007'
  #define HIST	'%'
  #define SUBST	'^'
  
- #define STDIN	0
- #define STDOUT	1
- 
  char sis_hist_char = HIST;       /* can be changed by "set hist_char" */
  
  static char *seperator = " \t\n;";
  
  /* Do not have access to file-completion in the HPUX systems ... */
  
! #if defined(hpux) || defined(SYSTYPE_BSD43) || defined(SYSTYPE_SYSV)
  char *
  fgets_filec(buf, size, stream, prompt)
  char *buf;
--- 23,44 ----
  #endif
  
  #define ESC	'\033'
+ 
  #define BEEP	'\007'
  #define HIST	'%'
  #define SUBST	'^'
  
  char sis_hist_char = HIST;       /* can be changed by "set hist_char" */
  
  static char *seperator = " \t\n;";
  
+ /* DAK: these are used outside file completion code */
+ #define STDIN	0
+ #define STDOUT	1
+ 
  /* Do not have access to file-completion in the HPUX systems ... */
  
! #if defined(hpux) || defined(SYSTYPE_BSD43) || defined(SYSTYPE_SYSV) 
  char *
  fgets_filec(buf, size, stream, prompt)
  char *buf;
***************
*** 83,89 ****
--- 89,99 ----
  char *prompt;
  {
      int n_read, i, len, maxlen, col, sno, modname;
+ #ifdef _POSIX_SOURCE
+     struct termios tchars, oldtchars;
+ #else
      struct tchars tchars, oldtchars;
+ #endif
      DIR *dir;
  #if defined(_IBMR2) || defined(__osf__)
      struct dirent *dp;
***************
*** 92,104 ****
  #endif
  #if !defined(_IBMR2)
      int omask;
      struct sgttyb tty, oldtty;	/* To mask interuupts */
  #endif
      char *last_word, *file, *path, *name, *line;
      char last_char, found[MAXNAMLEN];
      array_t *names;
      int pending = LPENDIN;
! 
      if (prompt != NIL(char)){
  	(void) print_prompt(prompt);
  	(void) fflush(stdout);
--- 102,117 ----
  #endif
  #if !defined(_IBMR2)
      int omask;
+ #ifndef __STDC__
      struct sgttyb tty, oldtty;	/* To mask interuupts */
  #endif
+ #endif
      char *last_word, *file, *path, *name, *line;
      char last_char, found[MAXNAMLEN];
      array_t *names;
+ #if !defined(__STDC__)    
      int pending = LPENDIN;
! #endif
      if (prompt != NIL(char)){
  	(void) print_prompt(prompt);
  	(void) fflush(stdout);
***************
*** 119,129 ****
  	return line;
      }
  	/* Allow hitting ESCAPE to break a read() */
! 	
      (void) ioctl(sno, TIOCGETC, (char *) &tchars);
      oldtchars = tchars;
      tchars.t_brkc = ESC;
      (void) ioctl(sno, TIOCSETC, (char *) &tchars);
  
      while ((n_read = read(sno, buf, size)) > 0) {
          buf[n_read] = '\0';
--- 132,148 ----
  	return line;
      }
  	/* Allow hitting ESCAPE to break a read() */
! #ifdef _POSIX_SOURCE
!     tcgetattr (sno, &tchars);
!     oldtchars = tchars;
!     tchars.c_cc[VEOL] = ESC;
!     tcsetattr(sno, TCSANOW, &tchars);
! #else
      (void) ioctl(sno, TIOCGETC, (char *) &tchars);
      oldtchars = tchars;
      tchars.t_brkc = ESC;
      (void) ioctl(sno, TIOCSETC, (char *) &tchars);
+ #endif
  
      while ((n_read = read(sno, buf, size)) > 0) {
          buf[n_read] = '\0';
***************
*** 130,136 ****
--- 149,159 ----
          last_word = &buf[n_read - 1];
          last_char = *last_word;
  	if (last_char == '\n' || n_read == size) {
+ #ifdef _POSIX_SOURCE
+ 	    tcsetattr(sno, TCSANOW, &oldtchars);
+ #else
  	    (void) ioctl(sno, TIOCSETC, (char *) &oldtchars);
+ #endif
  	    *last_word = '\0';
  	    return(buf);
  	}
***************
*** 225,231 ****
  	    *--file = '/';
  	}
  
! #if !defined(_IBMR2)
  		/* mask interrupts temporarily */
  	omask = sigblock(sigmask(SIGINT));	
  	(void) ioctl(STDOUT, TIOCGETP, (char *)&tty);
--- 248,254 ----
  	    *--file = '/';
  	}
  
! #if !defined(_IBMR2) && !defined(__STDC__)
  		/* mask interrupts temporarily */
  	omask = sigblock(sigmask(SIGINT));	
  	(void) ioctl(STDOUT, TIOCGETP, (char *)&tty);
***************
*** 242,248 ****
  	for (i = 0; buf[i]; i++) {
  	    (void) ioctl(STDOUT, TIOCSTI, &buf[i]);
  	}
! #if !defined(_IBMR2)
  		/* restore interrupts */
  	(void) ioctl(STDOUT, TIOCSETN, (char *)&oldtty);
  	(void) sigsetmask(omask);
--- 265,271 ----
  	for (i = 0; buf[i]; i++) {
  	    (void) ioctl(STDOUT, TIOCSTI, &buf[i]);
  	}
! #if !defined(_IBMR2) && !defined(__STDC__)
  		/* restore interrupts */
  	(void) ioctl(STDOUT, TIOCSETN, (char *)&oldtty);
  	(void) sigsetmask(omask);
***************
*** 250,256 ****
  #endif
      }
  	/* restore read() behavior */
!     (void) ioctl(sno, TIOCSETC, (char *) &oldtchars);
      return(NIL(char));
  }
  
--- 273,283 ----
  #endif
      }
  	/* restore read() behavior */
! #ifdef _POSIX_SOURCE
! 	    tcsetattr(sno, TCSANOW, &oldtchars);
! #else
! 	    (void) ioctl(sno, TIOCSETC, (char *) &oldtchars);
! #endif
      return(NIL(char));
  }
  
diff -r -c sis-1.2/sis/espresso/cvrin.c /projects/sis/sis-devel/common/src/sis/espresso/cvrin.c
*** sis-1.2/sis/espresso/cvrin.c	Thu May 14 08:44:06 1992
--- /projects/sis/sis-devel/common/src/sis/espresso/cvrin.c	Tue Sep 27 11:32:23 1994
***************
*** 300,307 ****
  	    } else if (equal(word, "p"))
  		(void) fscanf(fp, "%d", &np);
  	    /* .e and .end specify the end of the file */
! 	    else if (equal(word, "e") || equal(word,"end"))
! 		return;
  	    /* .kiss turns on the kiss-hack option */
  	    else if (equal(word, "kiss"))
  		kiss = TRUE;
--- 300,315 ----
  	    } else if (equal(word, "p"))
  		(void) fscanf(fp, "%d", &np);
  	    /* .e and .end specify the end of the file */
! 	    else if (equal(word, "e") || equal(word,"end")) {
!                 if (cube.fullset == NULL) {
!                     /* fatal("unknown PLA size, need .i/.o or .mv");*/
!                 } else if (PLA->F == NULL) {
!                     PLA->F = new_cover(10);
!                     PLA->D = new_cover(10);
!                     PLA->R = new_cover(10);
!                 }
!                 return;
!             }
  	    /* .kiss turns on the kiss-hack option */
  	    else if (equal(word, "kiss"))
  		kiss = TRUE;
diff -r -c sis-1.2/sis/extract/pingpong.c /projects/sis/sis-devel/common/src/sis/extract/pingpong.c
*** sis-1.2/sis/extract/pingpong.c	Mon Jul 19 15:21:52 1993
--- /projects/sis/sis-devel/common/src/sis/extract/pingpong.c	Thu Sep  1 13:00:27 1994
***************
*** 10,16 ****
  #include "sis.h"
  #include "extract_int.h"
  
! #define MAXINT	(1 << 30)
  
  
  static int
--- 10,16 ----
  #include "sis.h"
  #include "extract_int.h"
  
! #define PING_MAXINT	(1 << 30)
  
  
  static int
***************
*** 38,44 ****
      sm_row *prow, *best_row;
  
      /* choose row with maximum value */
!     max_value = - MAXINT;
      best_row = NIL(sm_row);
      sm_foreach_row(A, prow) {
  	value = row_value(prow, row_cost);
--- 38,44 ----
      sm_row *prow, *best_row;
  
      /* choose row with maximum value */
!     max_value = - PING_MAXINT;
      best_row = NIL(sm_row);
      sm_foreach_row(A, prow) {
  	value = row_value(prow, row_cost);
***************
*** 62,68 ****
      sm_row *prow, *best_row;
  
      /* choose row (in rect->rows) with maximum value */
!     max_value = - MAXINT;
      best_row = NIL(sm_row);
      sm_foreach_col_element(rect->rows, p) {
  	prow = sm_get_row(A, p->row_num);
--- 62,68 ----
      sm_row *prow, *best_row;
  
      /* choose row (in rect->rows) with maximum value */
!     max_value = - PING_MAXINT;
      best_row = NIL(sm_row);
      sm_foreach_col_element(rect->rows, p) {
  	prow = sm_get_row(A, p->row_num);
***************
*** 100,106 ****
      sm_col *pcol, *best_col;
  
      /* choose col with maximum value */
!     max_value = - MAXINT;
      best_col = NIL(sm_col);
      sm_foreach_col(A, pcol) {
  	value = col_value(pcol, col_cost);
--- 100,106 ----
      sm_col *pcol, *best_col;
  
      /* choose col with maximum value */
!     max_value = - PING_MAXINT;
      best_col = NIL(sm_col);
      sm_foreach_col(A, pcol) {
  	value = col_value(pcol, col_cost);
***************
*** 124,130 ****
      sm_col *pcol, *best_col;
  
      /* choose col (in rect->cols) with maximum value */
!     max_value = - MAXINT;
      best_col = NIL(sm_col);
      sm_foreach_row_element(rect->cols, p) {
  	pcol = sm_get_col(A, p->col_num);
--- 124,130 ----
      sm_col *pcol, *best_col;
  
      /* choose col (in rect->cols) with maximum value */
!     max_value = - PING_MAXINT;
      best_col = NIL(sm_col);
      sm_foreach_row_element(rect->cols, p) {
  	pcol = sm_get_col(A, p->col_num);
diff -r -c sis-1.2/sis/genlib/Makefile /projects/sis/sis-devel/common/src/sis/genlib/Makefile
*** sis-1.2/sis/genlib/Makefile	Fri Jul 15 15:48:31 1994
--- /projects/sis/sis-devel/common/src/sis/genlib/Makefile	Sat Oct 29 13:46:34 1994
***************
*** 20,26 ****
  PSRC	= aoi.c com_genlib.c comb.c count.c genlib.c io.c \
  	  nand.c permute.c readlib.c sptree.c
  POBJ	= $(PSRC:.c=.o)
! PHDR	= genlib.h genlib_yl.h sptree.h comb.h genlib_int.h
  MISC	= $(P).doc Makefile readlib.y readliblex.l
  
  TARGET	= sis
--- 20,26 ----
  PSRC	= aoi.c com_genlib.c comb.c count.c genlib.c io.c \
  	  nand.c permute.c readlib.c sptree.c
  POBJ	= $(PSRC:.c=.o)
! PHDR	= genlib.h sptree.h comb.h genlib_int.h
  MISC	= $(P).doc Makefile readlib.y readliblex.l
  
  TARGET	= sis
***************
*** 64,73 ****
  
  readlib.c: readlib.y readliblex.c
  	/usr/bin/yacc readlib.y
! 	mv y.tab.c readlib.c
  readliblex.c: readliblex.l
  	/usr/bin/lex readliblex.l
! 	mv lex.yy.c readliblex.c
  readlib.o: readlib.c readliblex.c
  	$(CC) -c $(CFLAGS) readlib.c
  	
--- 64,75 ----
  
  readlib.c: readlib.y readliblex.c
  	/usr/bin/yacc readlib.y
! 	sed < y.tab.c > readlib.c 's/yy/GENLIB_yy/g'
! 	rm -f y.tab.c
  readliblex.c: readliblex.l
  	/usr/bin/lex readliblex.l
! 	sed < lex.yy.c > readliblex.c 's/yy/GENLIB_yy/g'
! 	rm -f lex.yy.c
  readlib.o: readlib.c readliblex.c
  	$(CC) -c $(CFLAGS) readlib.c
  	
diff -r -c sis-1.2/sis/genlib/readlib.y /projects/sis/sis-devel/common/src/sis/genlib/readlib.y
*** sis-1.2/sis/genlib/readlib.y	Fri Jun  4 11:09:10 1993
--- /projects/sis/sis-devel/common/src/sis/genlib/readlib.y	Tue Aug 30 12:20:29 1994
***************
*** 12,29 ****
  /* last modified on 6/13/91 at 17:46:40   */
  #include <setjmp.h>
  #include "genlib_int.h"
- #include "genlib_yl.h"
  
  static int input();
  static int unput();
  static int yywrap();
  
  FILE *gl_out_file;
  #if defined(hpux) || defined(__osf__)
  extern unsigned char yytext[];
! #else 
  extern char yytext[];
  #endif
  
  static int global_use_nor;
  static function_t *global_fct;
--- 12,33 ----
  /* last modified on 6/13/91 at 17:46:40   */
  #include <setjmp.h>
  #include "genlib_int.h"
  
+ #undef yywrap 
  static int input();
  static int unput();
  static int yywrap();
  
  FILE *gl_out_file;
+ #ifdef YYBYACC
+ extern char *yytext;
+ #else
  #if defined(hpux) || defined(__osf__)
  extern unsigned char yytext[];
! #else
  extern char yytext[];
  #endif
+ #endif
  
  static int global_use_nor;
  static function_t *global_fct;
***************
*** 265,271 ****
  static char buffer[20];
  static jmp_buf jmpbuf;
  
! 
  static int
  input()
  {
--- 269,275 ----
  static char buffer[20];
  static jmp_buf jmpbuf;
  
! #ifndef FLEX_SCANNER
  static int
  input()
  {
***************
*** 295,302 ****
--- 299,338 ----
      if (c == '\n') read_lineno--;
      return c;
  }
+ #else
  
+ char *genlib_inp_ptr;
+ char* genlib_inp_lim;
  
+ int genlib_input(char* buf, int max_size)
+ {
+     char c;
+     int i, n;
+ 
+     if (! file_mode) {
+ 	if (max_size > (genlib_inp_lim - genlib_inp_ptr))
+ 	    n = genlib_inp_lim - genlib_inp_ptr;
+ 	else 
+ 	    n = max_size;	
+ 	if (n > 0) {
+ 	    for (i = 0; i < n; i++)
+ 		if (buf[i] == '\n') {
+ 		    read_lineno++;
+ 		    i++;
+ 		    break;
+ 		}
+ 	    memcpy (buf, genlib_inp_ptr, i);
+ 	    genlib_inp_ptr += i;
+ 	}
+     } else {
+ 	c = getc(yyin);
+ 	if (c == '\n') read_lineno++;
+ 	buf[0] = (c == EOF) ? (n = 0, YY_NULL) : (n = 1, c);
+     }
+     return n;
+ }
+ #endif
+ 
  static int
  library_setup_file(fp, filename)
  FILE *fp;
***************
*** 303,308 ****
--- 339,350 ----
  char *filename;
  {
      yyin = fp;
+ #ifdef FLEX_SCANNER 
+     yy_switch_to_buffer(
+                  yy_create_buffer( yyin, YY_BUF_SIZE ) );
+     yyrestart(yyin); 
+     BEGIN(INITIAL);
+ #endif
      file_mode = 1;
      nbuffer = 0;
      read_register_filename(filename);
***************
*** 315,320 ****
--- 357,369 ----
  {
      file_string = string;
      file_mode = 0;
+ #ifdef FLEX_SCANNER
+     yy_switch_to_buffer(
+                  yy_create_buffer( yyin, YY_BUF_SIZE ) );
+     yyrestart(yyin); 
+     genlib_inp_lim = string + strlen(string);
+     genlib_inp_ptr = string;
+ #endif
      nbuffer = 0;
      read_register_filename(NIL(char));
  }
***************
*** 328,340 ****
      longjmp(jmpbuf, 1);
  }
  
! 
  static int
  yywrap()
  {
      return 1;
  }
- 
  
  int
  gl_convert_genlib_to_blif(filename, use_nor)
--- 377,388 ----
      longjmp(jmpbuf, 1);
  }
  
! #undef yywrap 
  static int
  yywrap()
  {
      return 1;
  }
  
  int
  gl_convert_genlib_to_blif(filename, use_nor)
diff -r -c sis-1.2/sis/genlib/readliblex.l /projects/sis/sis-devel/common/src/sis/genlib/readliblex.l
*** sis-1.2/sis/genlib/readliblex.l	Thu May 14 08:48:01 1992
--- /projects/sis/sis-devel/common/src/sis/genlib/readliblex.l	Tue Aug 30 12:05:14 1994
***************
*** 3,8 ****
--- 3,12 ----
  /* last modified on 5/29/91 at 12:35:32   */
  #undef input
  #undef unput
+ #ifdef FLEX_SCANNER
+ #undef YY_INPUT
+ #define YY_INPUT(buf,result,max) (result = genlib_input(buf, max))
+ #endif
  /*alnum			[-A-Za-z0-9_.<>$%^&|{}[\]:,?/@]*/
  %}
  
diff -r -c sis-1.2/sis/include/spConfig.h /projects/sis/sis-devel/common/src/sis/include/spConfig.h
*** sis-1.2/sis/include/spConfig.h	Wed Apr 20 12:39:06 1994
--- /projects/sis/sis-devel/common/src/sis/include/spConfig.h	Thu Sep 22 19:46:08 1994
***************
*** 432,438 ****
  
  /* Begin machine constants. */
  
! #ifdef notdef  /* __STDC__ */
  /*
   * This code is currently deleted because most ANSI standard C compilers
   * do not provide the standard header files yet.
--- 432,438 ----
  
  /* Begin machine constants. */
  
! #ifdef __GNUC__
  /*
   * This code is currently deleted because most ANSI standard C compilers
   * do not provide the standard header files yet.
diff -r -c sis-1.2/sis/include/util.h /projects/sis/sis-devel/common/src/sis/include/util.h
*** sis-1.2/sis/include/util.h	Tue Jul 12 13:10:26 1994
--- /projects/sis/sis-devel/common/src/sis/include/util.h	Thu Sep  1 14:31:00 1994
***************
*** 22,27 ****
--- 22,31 ----
  #endif
  #endif
  
+ #if defined(__STDC__) || defined(sprite) || defined(_IBMR2) || defined(__osf__)
+ #include <unistd.h>
+ #endif
+ 
  #if defined(_IBMR2) && !defined(__STDC__)
  #define _BSD
  #endif
***************
*** 170,176 ****
  #define srandom(a) srand48(a)
  #define bzero(a,b) memset(a, 0, b)
  #else
! #if !defined(__osf__)
  extern VOID_HACK srandom();
  extern long random();
  #endif
--- 174,181 ----
  #define srandom(a) srand48(a)
  #define bzero(a,b) memset(a, 0, b)
  #else
! #if !defined(__osf__) && !defined(linux)
! /* these are defined as macros in stdlib.h */
  extern VOID_HACK srandom();
  extern long random();
  #endif
***************
*** 262,267 ****
--- 267,275 ----
  #define HUGE  8.9884656743115790e+307
  #endif
  #define HUGE_VAL HUGE
+ #endif
+ #ifndef MAXINT
+ #define MAXINT (1 << 30)
  #endif
  
  #include <varargs.h>
diff -r -c sis-1.2/sis/io/Makefile /projects/sis/sis-devel/common/src/sis/io/Makefile
*** sis-1.2/sis/io/Makefile	Fri Jul 15 15:48:35 1994
--- /projects/sis/sis-devel/common/src/sis/io/Makefile	Sat Oct 29 13:46:35 1994
***************
*** 20,26 ****
  	  write_bdnet.c write_blif.c write_eqn.c write_kiss.c \
  	  write_pla.c write_slif.c write_util.c 
  POBJ	= $(PSRC:.c=.o)
! PHDR	= io.h io_int.h io_yl.h
  MISC	= $(P).doc Makefile eqnlex.l read_eqn.y
  
  TARGET	= sis
--- 20,26 ----
  	  write_bdnet.c write_blif.c write_eqn.c write_kiss.c \
  	  write_pla.c write_slif.c write_util.c 
  POBJ	= $(PSRC:.c=.o)
! PHDR	= io.h io_int.h
  MISC	= $(P).doc Makefile eqnlex.l read_eqn.y
  
  TARGET	= sis
***************
*** 65,74 ****
  
  read_eqn.c: read_eqn.y
  	yacc read_eqn.y
! 	mv y.tab.c read_eqn.c
  eqnlex.c: eqnlex.l
  	lex eqnlex.l
! 	mv lex.yy.c eqnlex.c
  read_eqn.o: read_eqn.c eqnlex.c
  	$(CC) -c $(CFLAGS) read_eqn.c
  	
--- 65,76 ----
  
  read_eqn.c: read_eqn.y
  	yacc read_eqn.y
! 	sed < y.tab.c > read_eqn.c 's/yy/EQN_yy/g'
! 	rm -f y.tab.c
  eqnlex.c: eqnlex.l
  	lex eqnlex.l
! 	sed < lex.yy.c > eqnlex.c 's/yy/EQN_yy/g'
! 	rm -f lex.yy.c
  read_eqn.o: read_eqn.c eqnlex.c
  	$(CC) -c $(CFLAGS) read_eqn.c
  	
diff -r -c sis-1.2/sis/io/eqnlex.l /projects/sis/sis-devel/common/src/sis/io/eqnlex.l
*** sis-1.2/sis/io/eqnlex.l	Thu May 14 08:45:06 1992
--- /projects/sis/sis-devel/common/src/sis/io/eqnlex.l	Tue Aug 30 12:05:14 1994
***************
*** 1,9 ****
--- 1,14 ----
  %{
  #undef input
  #undef unput
+ #ifdef FLEX_SCANNER
+ #undef YY_INPUT
+ #define YY_INPUT(buf,result,max) (result = eqn_input(buf, max))
+ #endif
  %}
  
  blank			[ \n\t]
+ 
  alpha			[A-Za-z]
  alnum			[A-Za-z0-9_.,<>$%[\]:~/-]
  
***************
*** 58,60 ****
--- 63,66 ----
  .			{ yyerror("bad character"); }
  
  %%
+ 
diff -r -c sis-1.2/sis/io/read_eqn.y /projects/sis/sis-devel/common/src/sis/io/read_eqn.y
*** sis-1.2/sis/io/read_eqn.y	Fri Jun  4 11:07:53 1993
--- /projects/sis/sis-devel/common/src/sis/io/read_eqn.y	Tue Aug 30 12:24:23 1994
***************
*** 12,30 ****
  #include "io_int.h"
  #include <setjmp.h>
  
  extern char yytext[];
  static network_t *global_network;
  static lsList po_list;
  
  static int input();
  static int unput();
- static int yyerror();
  static int yywrap();
  
- /* this makes all yacc/lex symbols unique */
- #include "io_yl.h"
  
- 
  static void
  do_assign(name, expr)
  char *name;
--- 12,39 ----
  #include "io_int.h"
  #include <setjmp.h>
  
+ #ifdef YYBYACC
+ extern char *yytext;
+ #else
+ #if defined(hpux) || defined(__osf__)
+ extern unsigned char yytext[];
+ #else
  extern char yytext[];
+ #endif
+ #endif
+ 
  static network_t *global_network;
  static lsList po_list;
  
+ static int yyerror();
+ #ifndef FLEX_SCANNER
+ #undef yywrap
  static int input();
  static int unput();
  static int yywrap();
+ #endif
  
  
  static void
  do_assign(name, expr)
  char *name;
***************
*** 239,245 ****
  static int last_was_newline;
  static jmp_buf jmpbuf;
  
! 
  static int
  input()
  {
--- 248,254 ----
  static int last_was_newline;
  static jmp_buf jmpbuf;
  
! #ifndef FLEX_SCANNER
  static int
  input()
  {
***************
*** 265,271 ****
      return c;
  }
  
- 
  static int
  unput(c)
  int c;
--- 274,279 ----
***************
*** 273,280 ****
--- 281,322 ----
      if (nbuffer < 20) buffer[nbuffer++] = c;
      if (c == '\n') read_lineno--;
  }
+ #else
  
+ char *eqn_inp_ptr;
+ char* eqn_inp_lim;
  
+ int eqn_input(char* buf, int max_size)
+ {
+     char c;
+     int i, n;
+ 	 
+     if (! file_mode) {
+ 	if (max_size > (eqn_inp_lim - eqn_inp_ptr))
+ 	    n = eqn_inp_lim - eqn_inp_ptr;
+ 	else
+ 	    n= max_size;
+ 	if (n > 0) {
+ 	    for (i = 0; i < n; i++)
+ 		if (eqn_inp_ptr[i] == '\n') {
+ 		    read_lineno++;
+ 		    i++;
+ 		    break;
+ 		}
+ 	    memcpy (buf, eqn_inp_ptr, i);
+ 	    eqn_inp_ptr += i;
+ 	}
+     } else {
+ 	c = getc(yyin);
+ 	if (c == '\n')
+ 	    read_lineno++;
+ 	buf[0] = (c == EOF) ? (n = 0, YY_NULL) : (n = 1, c);
+     }
+     return n;
+ }
+ 
+ #endif
+ 
  static int
  equation_setup_string(s)
  char *s;
***************
*** 282,287 ****
--- 324,336 ----
      read_register_filename(NIL(char));
      file_mode = 0;
      string = s;
+ #ifdef FLEX_SCANNER
+     yy_switch_to_buffer(
+                  yy_create_buffer( yyin, YY_BUF_SIZE ) );
+     yyrestart(yyin); 
+     eqn_inp_lim = string + strlen(string);
+     eqn_inp_ptr = string;
+ #endif
      nbuffer = 0;
  }
  
***************
*** 291,296 ****
--- 340,351 ----
  FILE *fp;
  {
      yyin = fp;
+ #ifdef FLEX_SCANNER
+     yy_switch_to_buffer(
+                  yy_create_buffer( yyin, YY_BUF_SIZE ) );
+     yyrestart(yyin); 
+     BEGIN(INITIAL);
+ #endif
      file_mode = 1;
      nbuffer = 0;
      last_was_newline = 1;
***************
*** 305,316 ****
      longjmp(jmpbuf, 1);
  }
  
! 
  static int
  yywrap()
  {
      return 1;
  }
  
  network_t *
  read_eqn(fp)
--- 360,372 ----
      longjmp(jmpbuf, 1);
  }
  
! #undef yywrap
  static int
  yywrap()
  {
      return 1;
  }
+ 
  
  network_t *
  read_eqn(fp)
diff -r -c sis-1.2/sis/linsolv/spAllocate.c /projects/sis/sis-devel/common/src/sis/linsolv/spAllocate.c
*** sis-1.2/sis/linsolv/spAllocate.c	Wed Apr 20 12:39:06 1994
--- /projects/sis/sis-devel/common/src/sis/linsolv/spAllocate.c	Thu Sep  1 14:21:01 1994
***************
*** 38,43 ****
--- 38,46 ----
   *  ExpandTranslationArrays
   */
  
+ static void InitializeElementBlocks();
+ static void RecordAllocation();
+ static void AllocateBlockOfAllocationList();
  
  /*
   *  Revision and copyright information.
***************
*** 377,383 ****
   *  spNO_MEMORY
   */
  
! static
  InitializeElementBlocks( Matrix, InitialNumberOfElements,
                           NumberOfFillinsExpected )
  
--- 380,386 ----
   *  spNO_MEMORY
   */
  
! static void
  InitializeElementBlocks( Matrix, InitialNumberOfElements,
                           NumberOfFillinsExpected )
  
***************
*** 520,526 ****
   *  spNO_MEMORY
   */
  
! static
  RecordAllocation( Matrix, AllocatedPtr )
  
  MatrixPtr Matrix;
--- 523,529 ----
   *  spNO_MEMORY
   */
  
! static void
  RecordAllocation( Matrix, AllocatedPtr )
  
  MatrixPtr Matrix;
***************
*** 577,583 ****
   *  spNO_MEMORY
   */
  
! static
  AllocateBlockOfAllocationList( Matrix )
  
  MatrixPtr Matrix;
--- 580,586 ----
   *  spNO_MEMORY
   */
  
! static void
  AllocateBlockOfAllocationList( Matrix )
  
  MatrixPtr Matrix;
diff -r -c sis-1.2/sis/linsolv/spConfig.h /projects/sis/sis-devel/common/src/sis/linsolv/spConfig.h
*** sis-1.2/sis/linsolv/spConfig.h	Wed Apr 20 12:39:06 1994
--- /projects/sis/sis-devel/common/src/sis/linsolv/spConfig.h	Thu Sep 22 19:46:08 1994
***************
*** 432,438 ****
  
  /* Begin machine constants. */
  
! #ifdef notdef  /* __STDC__ */
  /*
   * This code is currently deleted because most ANSI standard C compilers
   * do not provide the standard header files yet.
--- 432,438 ----
  
  /* Begin machine constants. */
  
! #ifdef __GNUC__
  /*
   * This code is currently deleted because most ANSI standard C compilers
   * do not provide the standard header files yet.
diff -r -c sis-1.2/sis/linsolv/spFactor.c /projects/sis/sis-devel/common/src/sis/linsolv/spFactor.c
*** sis-1.2/sis/linsolv/spFactor.c	Wed Apr 20 12:39:08 1994
--- /projects/sis/sis-devel/common/src/sis/linsolv/spFactor.c	Thu Sep  1 14:26:24 1994
***************
*** 36,42 ****
   *  WriteStatus
   */
  
- 
  /*
   *  Revision and copyright information.
   *
--- 36,41 ----
***************
*** 79,88 ****
  #include "spMatrix.h"
  #include "spDefs.h"
  
  
  
- 
- 
  
  /*
   *  ORDER AND FACTOR MATRIX
--- 78,102 ----
  #include "spMatrix.h"
  #include "spDefs.h"
  
+ static void CreateInternalVectors();
+ static void CountMarkowitz();
+ static void MarkowitzProducts();
+ static ElementPtr SearchForPivot();
+ static ElementPtr SearchForSingleton();
+ static ElementPtr SearchEntireMatrix();
+ static RealNumber FindLargestInCol();
+ static RealNumber FindBiggestInColExclude();
+ static void ExchangeRowsAndCols();
+ static void ExchangeColElements();
+ static void ExchangeRowElements();
+ static void RealRowColElimination();
+ static void ComplexRowColElimination();
+ static void UpdateMarkowitzNumbers();
+ static ElementPtr CreateFillin();
+ static int MatrixIsSingular();
+ static int ZeroPivot();
  
  
  
  /*
   *  ORDER AND FACTOR MATRIX
***************
*** 728,734 ****
   *  spNO_MEMORY
   */
  
! static
  CreateInternalVectors( Matrix )
  
  MatrixPtr  Matrix;
--- 742,748 ----
   *  spNO_MEMORY
   */
  
! static void
  CreateInternalVectors( Matrix )
  
  MatrixPtr  Matrix;
***************
*** 817,823 ****
   *     The size of the matrix.
   */
  
! static
  CountMarkowitz( Matrix, RHS, Step )
  
  MatrixPtr Matrix;
--- 831,837 ----
   *     The size of the matrix.
   */
  
! static void
  CountMarkowitz( Matrix, RHS, Step )
  
  MatrixPtr Matrix;
***************
*** 927,933 ****
   *      The size of the matrix.
   */
  
! static
  MarkowitzProducts( Matrix, Step )
  
  MatrixPtr Matrix;
--- 941,947 ----
   *      The size of the matrix.
   */
  
! static void
  MarkowitzProducts( Matrix, Step )
  
  MatrixPtr Matrix;
***************
*** 2084,2090 ****
   *      of the reduced submatrix.
   */
  
! static
  ExchangeRowsAndCols( Matrix, pPivot, Step )
  
  MatrixPtr Matrix;
--- 2098,2104 ----
   *      of the reduced submatrix.
   */
  
! static void
  ExchangeRowsAndCols( Matrix, pPivot, Step )
  
  MatrixPtr Matrix;
***************
*** 2421,2427 ****
   *      Pointer used to traverse the column.
   */
  
! static
  ExchangeColElements( Matrix, Row1, Element1, Row2, Element2, Column )
  
  MatrixPtr Matrix;
--- 2435,2441 ----
   *      Pointer used to traverse the column.
   */
  
! static void
  ExchangeColElements( Matrix, Row1, Element1, Row2, Element2, Column )
  
  MatrixPtr Matrix;
***************
*** 2563,2569 ****
   *      Pointer used to traverse the row.
   */
  
! static
  ExchangeRowElements( Matrix, Col1, Element1, Col2, Element2, Row )
  
  MatrixPtr Matrix;
--- 2577,2583 ----
   *      Pointer used to traverse the row.
   */
  
! static void
  ExchangeRowElements( Matrix, Col1, Element1, Col2, Element2, Row )
  
  MatrixPtr Matrix;
***************
*** 2698,2704 ****
   *  spNO_MEMORY
   */
  
! static
  RealRowColElimination( Matrix, pPivot )
  
  MatrixPtr Matrix;
--- 2712,2718 ----
   *  spNO_MEMORY
   */
  
! static void
  RealRowColElimination( Matrix, pPivot )
  
  MatrixPtr Matrix;
***************
*** 2787,2793 ****
   *  spNO_MEMORY
   */
  
! static
  ComplexRowColElimination( Matrix, pPivot )
  
  MatrixPtr Matrix;
--- 2801,2807 ----
   *  spNO_MEMORY
   */
  
! static void
  ComplexRowColElimination( Matrix, pPivot )
  
  MatrixPtr Matrix;
***************
*** 2871,2877 ****
   *      Points to matrix element in lower triangular row.
   */
  
! static
  UpdateMarkowitzNumbers( Matrix, pPivot )
  
  MatrixPtr Matrix;
--- 2885,2891 ----
   *      Points to matrix element in lower triangular row.
   */
  
! static void
  UpdateMarkowitzNumbers( Matrix, pPivot )
  
  MatrixPtr Matrix;
diff -r -c sis-1.2/sis/main/version.c /projects/sis/sis-devel/common/src/sis/main/version.c
*** sis-1.2/sis/main/version.c	Fri Jul 15 13:57:35 1994
--- /projects/sis/sis-devel/common/src/sis/main/version.c	Fri Oct 28 16:25:50 1994
***************
*** 16,23 ****
  
  #ifndef CUR_VER
  #ifdef SIS
! /*#define CUR_VER		"UC Berkeley, SIS Release 1.1" */
! #define CUR_VER		"UC Berkeley, SIS Development Version"
  #else
  #define CUR_VER         "UC Berkeley, MIS Release 2.2"
  #endif
--- 16,22 ----
  
  #ifndef CUR_VER
  #ifdef SIS
! #define CUR_VER		"UC Berkeley, SIS 1.3"
  #else
  #define CUR_VER         "UC Berkeley, MIS Release 2.2"
  #endif
diff -r -c sis-1.2/sis/network/network_util.c /projects/sis/sis-devel/common/src/sis/network/network_util.c
*** sis-1.2/sis/network/network_util.c	Wed Jun  2 13:37:52 1993
--- /projects/sis/sis-devel/common/src/sis/network/network_util.c	Tue Sep 27 10:09:06 1994
***************
*** 768,773 ****
--- 768,774 ----
  
  /* generate external don't care function for PO in the care network*/
      n3= node_constant(0);
+     if (dcnodep->F == 0) return n3;
        foreach_set(dcnodep->F, last, setp) {
          n1= node_constant(1);
          for(k=0 ; k< dcnodep->nin; k++){
diff -r -c sis-1.2/sis/node/names.c /projects/sis/sis-devel/common/src/sis/node/names.c
*** sis-1.2/sis/node/names.c	Thu May 14 08:48:19 1992
--- /projects/sis/sis-devel/common/src/sis/node/names.c	Mon Sep 12 14:38:08 1994
***************
*** 1,10 ****
  /*
   * Revision Control Information
   *
!  * $Source: /vol/opua/opua2/sis/sis-1.1/common/src/sis/node/RCS/names.c,v $
!  * $Author: sis $
!  * $Revision: 1.3 $
!  * $Date: 1992/05/06 18:57:41 $
   *
   */
  #include "sis.h"
--- 1,10 ----
  /*
   * Revision Control Information
   *
!  * $Source: /projects/hwsw/hwsw/common/src/polis/misc/node/RCS/names.c,v $
!  * $Author: luciano $
!  * $Revision: 1.2 $
!  * $Date: 1994/09/11 20:44:09 $
   *
   */
  #include "sis.h"
***************
*** 50,58 ****
  node_assign_name(node)
  node_t *node;
  {
      if (node->name != NIL(char)) FREE(node->name);
!     node->name = ALLOC(char, 10);
!     (void) sprintf(node->name, "[%d]", long_name_index);
      long_name_index++;
  }
  
--- 50,60 ----
  node_assign_name(node)
  node_t *node;
  {
+ 	static char buf[80];
      if (node->name != NIL(char)) FREE(node->name);
!     (void) sprintf(buf, "[%d]", long_name_index);
!     node->name = ALLOC(char, strlen(buf) + 1);
! 	strcpy (node->name, buf);
      long_name_index++;
  }
  
diff -r -c sis-1.2/sis/pld/act_bool.c /projects/sis/sis-devel/common/src/sis/pld/act_bool.c
*** sis-1.2/sis/pld/act_bool.c	Mon Mar  7 22:48:27 1994
--- /projects/sis/sis-devel/common/src/sis/pld/act_bool.c	Thu Sep  1 13:14:39 1994
***************
*** 6,11 ****
--- 6,13 ----
  *   Jan 29 '93 - added act_is_or_used.
  */
  
+ static node_t *act_form_G();
+ 
  /*--------------------------------------------------------------------------------
    This includes routines for Boolean matching of a function against actel block.
    In the spirit of ENUFOR... Assumes that the nodes are expressed using 
diff -r -c sis-1.2/sis/pld/act_collapse.c /projects/sis/sis-devel/common/src/sis/pld/act_collapse.c
*** sis-1.2/sis/pld/act_collapse.c	Mon Mar  7 22:48:27 1994
--- /projects/sis/sis-devel/common/src/sis/pld/act_collapse.c	Thu Sep  1 13:14:50 1994
***************
*** 14,19 ****
--- 14,21 ----
  #include "pld_int.h"
  #include "math.h"
  
+ static node_t *act_partial_collapse_find_max_score();
+ 
  /*----------------------------------------------------------------------------------
    This file has routines for partial collapse of a node without using lindo.
  ----------------------------------------------------------------------------------*/
diff -r -c sis-1.2/sis/pld/act_map.c /projects/sis/sis-devel/common/src/sis/pld/act_map.c
*** sis-1.2/sis/pld/act_map.c	Mon Mar  7 22:48:29 1994
--- /projects/sis/sis-devel/common/src/sis/pld/act_map.c	Thu Sep  1 13:15:02 1994
***************
*** 8,13 ****
--- 8,15 ----
  #include "sis.h"
  #include "pld_int.h"
  
+ static int map_act_delay();
+ 
  array_t *multiple_fo_array; /* holds the nodes that have multiple_fo in the act */
  array_t *num_mux_struct_array; /* holds the cost of each multiple_fo act */
  array_t *my_node_array;
diff -r -c sis-1.2/sis/pld/ite_collapse.c /projects/sis/sis-devel/common/src/sis/pld/ite_collapse.c
*** sis-1.2/sis/pld/ite_collapse.c	Mon Mar  7 22:48:30 1994
--- /projects/sis/sis-devel/common/src/sis/pld/ite_collapse.c	Thu Sep  1 13:15:07 1994
***************
*** 3,8 ****
--- 3,10 ----
  #include "ite_int.h"
  #include "math.h" 
  
+ static node_t * act_ite_partial_collapse_find_max_score();
+ 
  /* Aug 21, 1991 - changed the collapse routine for node to take care of 
     no duplication of the network when a collapse is considered. */
  
diff -r -c sis-1.2/sis/pld/ite_imp.c /projects/sis/sis-devel/common/src/sis/pld/ite_imp.c
*** sis-1.2/sis/pld/ite_imp.c	Mon Mar  7 22:48:31 1994
--- /projects/sis/sis-devel/common/src/sis/pld/ite_imp.c	Thu Sep  1 14:37:09 1994
***************
*** 2,7 ****
--- 2,9 ----
  #include "pld_int.h"
  #include "ite_int.h"
  
+ static void ite_decomp_big_nodes();
+ 
  /*
    Log of changes
  
***************
*** 82,88 ****
    implemented in misII.
  -----------------------------------------------------------------------------*/
  
! static
  ite_decomp_big_nodes(network, gain, init_param)
    network_t      *network;
    int     	 *gain;
--- 84,90 ----
    implemented in misII.
  -----------------------------------------------------------------------------*/
  
! static void
  ite_decomp_big_nodes(network, gain, init_param)
    network_t      *network;
    int     	 *gain;
diff -r -c sis-1.2/sis/pld/ite_map.c /projects/sis/sis-devel/common/src/sis/pld/ite_map.c
*** sis-1.2/sis/pld/ite_map.c	Mon Mar  7 22:48:31 1994
--- /projects/sis/sis-devel/common/src/sis/pld/ite_map.c	Thu Sep  1 14:38:38 1994
***************
*** 2,7 ****
--- 2,9 ----
  #include "pld_int.h"
  #include "ite_int.h"
  
+ static void act_initialize_ite_area();
+ 
  ite_vertex_ptr PRESENT_ITE;
  extern int WHICH_ACT;
  
***************
*** 500,506 ****
     multiple_fo_array.  
  ------------------------------------------------------------------------*/
  
! static
  act_initialize_ite_area(vertex, multiple_fo_array)
     ite_vertex_ptr vertex;
     array_t *multiple_fo_array;
--- 502,508 ----
     multiple_fo_array.  
  ------------------------------------------------------------------------*/
  
! static void
  act_initialize_ite_area(vertex, multiple_fo_array)
     ite_vertex_ptr vertex;
     array_t *multiple_fo_array;
diff -r -c sis-1.2/sis/pld/pld_int.h /projects/sis/sis-devel/common/src/sis/pld/pld_int.h
*** sis-1.2/sis/pld/pld_int.h	Mon Mar  7 22:48:35 1994
--- /projects/sis/sis-devel/common/src/sis/pld/pld_int.h	Thu Sep  1 12:59:35 1994
***************
*** 351,357 ****
  
  /* xln_merge and xln_map_par*/
  #define MAX_MATCHING	1000
- #define MAXINT          100000000
  #define BUFSIZE		500
  
  #define SOURCE_NAME	"source"
--- 351,356 ----
diff -r -c sis-1.2/sis/pld/xln_merge.c /projects/sis/sis-devel/common/src/sis/pld/xln_merge.c
*** sis-1.2/sis/pld/xln_merge.c	Mon Mar  7 22:48:34 1994
--- /projects/sis/sis-devel/common/src/sis/pld/xln_merge.c	Tue Oct 18 13:11:53 1994
***************
*** 114,120 ****
      array_t	*fanin_array;
      array_t	*fanin_nodes;
      array_t	*fanin1, *fanin2;
!     node_t	*node;
      node_t	*fanin;
      node_t	*node1, *node2;
      int		i, j;
--- 114,120 ----
      array_t	*fanin_array;
      array_t	*fanin_nodes;
      array_t	*fanin1, *fanin2;
!     node_t	*node, *fo;
      node_t	*fanin;
      node_t	*node1, *node2;
      int		i, j;
***************
*** 250,255 ****
--- 250,261 ----
      for(i = 0; i < array_n(match1_array); i++) {
  	node1 = array_fetch(node_t *, match1_array, i);
  	node2 = array_fetch(node_t *, match2_array, i);
+         if (io_po_fanout_count(node1, &fo) == 1) {
+             node1 = fo;
+         }
+         if (io_po_fanout_count(node2, &fo) == 1) {
+             node2 = fo;
+         }
  	(void) fprintf(outputFile, "Merge node %s and %s\n", 
  			  node_long_name(node1), node_long_name(node2));
  	if (verbose) (void) printf("Merge node %s and %s\n", 
***************
*** 411,413 ****
--- 417,421 ----
    }
    return 1;
  }
+ 
+ 
diff -r -c sis-1.2/sis/seqbdd/prl_extract.c /projects/sis/sis-devel/common/src/sis/seqbdd/prl_extract.c
*** sis-1.2/sis/seqbdd/prl_extract.c	Tue Mar  1 11:46:09 1994
--- /projects/sis/sis-devel/common/src/sis/seqbdd/prl_extract.c	Thu Sep 29 13:54:04 1994
***************
*** 1,16 ****
  /*
   * Revision Control Information
   *
!  * $Source: /vol/opua/opua2/sis/sis-1.2/common/src/sis/seqbdd/RCS/prl_extract.c,v $
!  * $Author: sis $
!  * $Revision: 1.1 $
!  * $Date: 1993/07/15 18:11:01 $
   *
   */
  
   /* this file provides the basic functions of the sequential BDD package */
  
- #ifdef SIS
  #include "sis.h"
  #include "prl_seqbdd.h"
  #include "prl_util.h"
--- 1,15 ----
  /*
   * Revision Control Information
   *
!  * $Source$
!  * $Author$
!  * $Revision$
!  * $Date$
   *
   */
  
   /* this file provides the basic functions of the sequential BDD package */
  
  #include "sis.h"
  #include "prl_seqbdd.h"
  #include "prl_util.h"
***************
*** 391,401 ****
    *
    * MakeFsmInputRelation -- INTERNAL ROUTINE
    *
!   * Builds a BDD that is the conjunction (and) of expressions
!   * of the form: x == f(input,state)
!   * where 'input' and 'state' relate to the product env x fsm
!   * and 'x' relates to an input of the 'fsm'.
    *
    *----------------------------------------------------------------------
    */
  
--- 390,409 ----
    *
    * MakeFsmInputRelation -- INTERNAL ROUTINE
    *
!   * Builds the AND of expressions of the form: (x[i] XNOR fn[i](input,state))
!   * for each input of the FSM that is bound to an output of the environment.
    *
+   * Side Effects:
+   * For each input of the FSM that is bound to an output of the environment
+   * we introduce a new primary input that is added to seq_info->network.
+   * That primary input is given a BDD variable (inserted in seq_info->input_vars)
+   * and seq_info->input_nodes and seq_info->var_names are updated accordingly.
+   *
+   * NOTES:
+   * The index in seq_info->var_names should always be equal to the
+   * BDD variable associated with the corresponding input. This is checked
+   * by an assertion.
+   *
    *----------------------------------------------------------------------
    */
  
***************
*** 403,454 ****
  seq_info_t *seq_info;
  array_t *controlled_fsm_inputs;
  {
!     int i;
!     bdd_t *result;
!     bdd_t *fn, *var, *tmp, *new_result;
!     node_t *pi;
!     Connection connection;
!     /* inputs of fsm, outputs of env */
!     array_t *new_input_vars = array_alloc(bdd_t *, 0);
  
!     /* add new variables for the controlled fsm inputs */
!     for (i = 0; i < array_n(controlled_fsm_inputs); i++) {
! 	bdd_t *var = bdd_create_variable(seq_info->manager);
! 	array_insert_last(bdd_t *, new_input_vars, var);
      }
  
!     /* add corresponding variables to seq_info and primary inputs to the network */
!     for (i = 0; i < array_n(controlled_fsm_inputs); i++) {
! 	connection = array_fetch(Connection, controlled_fsm_inputs, i);
! 	if (connection.copy_output == NIL(node_t)) continue;
! 	var = array_fetch(bdd_t *, new_input_vars, i);
! 	var = bdd_dup(var);
! 	array_insert_last(bdd_t *, seq_info->input_vars, var);
! 	pi = node_alloc();
! 	pi->name = util_strsav(connection.input_name);
! 	network_add_primary_input(seq_info->network, pi);
! 	array_insert_last(node_t *, seq_info->input_nodes, pi);
! 	array_insert_last(char *, seq_info->var_names, util_strsav(pi->name));
      }
  
!     /* build the resulting bdd */
!     result = bdd_one(seq_info->manager);
!     for (i = 0; i < array_n(controlled_fsm_inputs); i++) {
! 	connection = array_fetch(Connection, controlled_fsm_inputs, i);
! 	if (connection.copy_output == NIL(node_t)) continue;
! 	fn = ntbdd_node_to_bdd(connection.copy_output, seq_info->manager, seq_info->leaves);
! 	var = array_fetch(bdd_t *, new_input_vars, i);
! 	tmp = bdd_xnor(var, fn);
! 	new_result = bdd_and(tmp, result, 1, 1);
! 	bdd_free(tmp);
! 	bdd_free(result);
! 	result = new_result;
      }
!     Prl_FreeBddArray(new_input_vars);
!     return result;
  }
  
  
  typedef int (*CheckFn) ARGS((bdd_t *, bdd_t *, seq_info_t *, prl_options_t *, void *));
  static  int  CheckCurrentStateTautology ARGS((bdd_t *, bdd_t *, seq_info_t *, prl_options_t *, void *));
  
--- 411,473 ----
  seq_info_t *seq_info;
  array_t *controlled_fsm_inputs;
  {
!   int i;
!   bdd_t *result;
!   bdd_t *fn, *var, *tmp, *new_result;
!   node_t *pi;
!   Connection connection;
!   /* inputs of fsm, outputs of env */
!   array_t *new_input_vars = array_alloc(bdd_t *, 0);
  
!   /* Add new variables for the controlled fsm inputs. */
!   for (i = 0; i < array_n(controlled_fsm_inputs); i++) {
!     connection = array_fetch(Connection, controlled_fsm_inputs, i);
!     if (connection.copy_output != NIL(node_t)) {
!       bdd_t *var = bdd_create_variable(seq_info->manager);
!       array_insert_last(bdd_t *, new_input_vars, var);
!     } 
!     else {
!       /* Unused entries. Should be BDDs for Prl_FreeBddArray. */
!       array_insert_last(bdd_t *, new_input_vars, bdd_one(seq_info->manager));
      }
+   }
  
!   /* Add corresponding variables to seq_info and primary inputs to the network. */
!   for (i = 0; i < array_n(controlled_fsm_inputs); i++) {
!     connection = array_fetch(Connection, controlled_fsm_inputs, i);
!     if (connection.copy_output != NIL(node_t)) {
!       var = array_fetch(bdd_t *, new_input_vars, i);
!       var = bdd_dup(var);
!       array_insert_last(bdd_t *, seq_info->input_vars, var);
!       pi = node_alloc();
!       pi->name = util_strsav(connection.input_name);
!       network_add_primary_input(seq_info->network, pi);
!       array_insert_last(node_t *, seq_info->input_nodes, pi);
!       array_insert_last(char *, seq_info->var_names, util_strsav(pi->name));
!       assert(bdd_top_var_id(var) == array_n(seq_info->var_names) - 1);
      }
+   }
  
!   /* Build the resulting bdd. */
!   result = bdd_one(seq_info->manager);
!   for (i = 0; i < array_n(controlled_fsm_inputs); i++) {
!     connection = array_fetch(Connection, controlled_fsm_inputs, i);
!     if (connection.copy_output != NIL(node_t)) {
!       fn = ntbdd_node_to_bdd(connection.copy_output, seq_info->manager, seq_info->leaves);
!       var = array_fetch(bdd_t *, new_input_vars, i);
!       tmp = bdd_xnor(var, fn);
!       new_result = bdd_and(tmp, result, 1, 1);
!       bdd_free(tmp);
!       bdd_free(result);
!       result = new_result;
      }
!   }
!   Prl_FreeBddArray(new_input_vars);
!   return result;
  }
  
  
+ 
  typedef int (*CheckFn) ARGS((bdd_t *, bdd_t *, seq_info_t *, prl_options_t *, void *));
  static  int  CheckCurrentStateTautology ARGS((bdd_t *, bdd_t *, seq_info_t *, prl_options_t *, void *));
  
***************
*** 1159,1163 ****
      }
      array_free(connections);
  }
! #endif /* SIS */
  
--- 1178,1182 ----
      }
      array_free(connections);
  }
! 
  
diff -r -c sis-1.2/sis/sis_lib/help/print.1 /projects/sis/sis-devel/common/src/sis/sis_lib/help/print.1
*** sis-1.2/sis/sis_lib/help/print.1	Thu May 14 08:42:05 1992
--- /projects/sis/sis-devel/common/src/sis/sis_lib/help/print.1	Wed Jul 20 11:42:09 1994
***************
*** 13,19 ****
  Print all the nodes in the \fBnode-list\fR in sum-of-product form.
  .PP
  If \fB-n\fR option is specified, the nodes are printed in
! the negative form. (i.e. a' + b' will be printed as (a + b)').
  .PP
  If \fB-d\fR option is specified, the nodes in the external
  don't care network are printed.
--- 13,19 ----
  Print all the nodes in the \fBnode-list\fR in sum-of-product form.
  .PP
  If \fB-n\fR option is specified, the nodes are printed in
! the negative form. (i.e. a' + b' will be printed as (a b)').
  .PP
  If \fB-d\fR option is specified, the nodes in the external
  don't care network are printed.
diff -r -c sis-1.2/sis/speed/gbx.c /projects/sis/sis-devel/common/src/sis/speed/gbx.c
*** sis-1.2/sis/speed/gbx.c	Thu Jul 15 20:04:48 1993
--- /projects/sis/sis-devel/common/src/sis/speed/gbx.c	Thu Sep  1 12:59:18 1994
***************
*** 19,25 ****
  #include "speed_int.h"
  #include "gbx_int.h"
  
- #define MAXINT 0x7fffffff
  #define GBX_MAXWEIGHT 0x7ffffffe
  
  st_table *bypass_table;
--- 19,24 ----
diff -r -c sis-1.2/sis/util/util.h /projects/sis/sis-devel/common/src/sis/util/util.h
*** sis-1.2/sis/util/util.h	Tue Jul 12 13:10:26 1994
--- /projects/sis/sis-devel/common/src/sis/util/util.h	Thu Sep  1 14:31:00 1994
***************
*** 22,27 ****
--- 22,31 ----
  #endif
  #endif
  
+ #if defined(__STDC__) || defined(sprite) || defined(_IBMR2) || defined(__osf__)
+ #include <unistd.h>
+ #endif
+ 
  #if defined(_IBMR2) && !defined(__STDC__)
  #define _BSD
  #endif
***************
*** 170,176 ****
  #define srandom(a) srand48(a)
  #define bzero(a,b) memset(a, 0, b)
  #else
! #if !defined(__osf__)
  extern VOID_HACK srandom();
  extern long random();
  #endif
--- 174,181 ----
  #define srandom(a) srand48(a)
  #define bzero(a,b) memset(a, 0, b)
  #else
! #if !defined(__osf__) && !defined(linux)
! /* these are defined as macros in stdlib.h */
  extern VOID_HACK srandom();
  extern long random();
  #endif
***************
*** 262,267 ****
--- 267,275 ----
  #define HUGE  8.9884656743115790e+307
  #endif
  #define HUGE_VAL HUGE
+ #endif
+ #ifndef MAXINT
+ #define MAXINT (1 << 30)
  #endif
  
  #include <varargs.h>
diff -r -c sis-1.2/stamina/hash/hash.h /projects/sis/sis-devel/common/src/stamina/hash/hash.h
*** sis-1.2/stamina/hash/hash.h	Fri Jul 15 15:58:49 1994
--- /projects/sis/sis-devel/common/src/stamina/hash/hash.h	Thu Jul 21 10:56:35 1994
***************
*** 20,25 ****
--- 20,26 ----
  struct nlist {  /* basic table entry */
  	char *name;
  	int *ptr;		/* this element is not used */
+ 	int *nptr;		/* For the new flow table */
  	int order_index;	/* order index of entries in hashtab */
  	NLIST *h_next;		/* Horizontal chain for flow table */
  	NLIST *h_prev;
***************
*** 26,35 ****
  	struct nlist *next; 	/* next entry in chain */
  };
  
- 
  /*NLIST **hashtab;*/	/* the hashtable should be allocated in 
  			   the calling function by calling 
  			   hash_initial() .            */
- 
- 
- 
--- 27,32 ----
diff -r -c sis-1.2/stamina/hash/hash_initial.c /projects/sis/sis-devel/common/src/stamina/hash/hash_initial.c
*** sis-1.2/stamina/hash/hash_initial.c	Fri Jul 15 15:58:48 1994
--- /projects/sis/sis-devel/common/src/stamina/hash/hash_initial.c	Thu Jul 21 10:57:32 1994
***************
*** 38,44 ****
  
  }
  
- 
  char *str_save(s)		/* save a string 's' somewhere */
  char *s;
  {
--- 38,43 ----
diff -r -c sis-1.2/stamina/hash/install.c /projects/sis/sis-devel/common/src/stamina/hash/install.c
*** sis-1.2/stamina/hash/install.c	Fri Jul 15 15:58:48 1994
--- /projects/sis/sis-devel/common/src/stamina/hash/install.c	Thu Jul 21 10:58:07 1994
***************
*** 70,77 ****
  NLIST 
  *install_input(name, hashtab, hash_size)
  char *name;
! /* char *ptr;		/* Pointer to first structure */
! /* int order;		/* order index of entries in hashtab */
  NLIST *hashtab[];
  {
  	NLIST *np;	/* a pointer to nlist */
--- 70,77 ----
  NLIST 
  *install_input(name, hashtab, hash_size)
  char *name;
! /* char *ptr;		Pointer to first structure */
! /* int order;		order index of entries in hashtab */
  NLIST *hashtab[];
  {
  	NLIST *np;	/* a pointer to nlist */
diff -r -c sis-1.2/stamina/mimi/bcover.c /projects/sis/sis-devel/common/src/stamina/mimi/bcover.c
*** sis-1.2/stamina/mimi/bcover.c	Fri Jul 15 15:58:51 1994
--- /projects/sis/sis-devel/common/src/stamina/mimi/bcover.c	Thu Jul 21 11:59:31 1994
***************
*** 7,13 ****
   * $Date: 1994/07/15 22:58:50 $
   *
   */
! /* SCCSID %W% */
  #include "user.h"
  #include "util.h"
  #include "struct.h"
--- 7,13 ----
   * $Date: 1994/07/15 22:58:50 $
   *
   */
! 
  #include "user.h"
  #include "util.h"
  #include "struct.h"
diff -r -c sis-1.2/stamina/mimi/main.c /projects/sis/sis-devel/common/src/stamina/mimi/main.c
*** sis-1.2/stamina/mimi/main.c	Fri Jul 15 15:58:55 1994
--- /projects/sis/sis-devel/common/src/stamina/mimi/main.c	Wed Jul 20 12:57:19 1994
***************
*** 49,55 ****
  	user.cmd.shrink = 0;
  	user.cmd.trans = 0;
  	
! 	while ((c = getopt(argc, argv, "tcrhSRCMPs:m:b:v:o:")) != EOF) {
  		switch(c) {
  		case 's':
  			if ((user.opt.solution=atoi(util_optarg)) > 3)
--- 49,55 ----
  	user.cmd.shrink = 0;
  	user.cmd.trans = 0;
  	
! 	while ((c = util_getopt(argc, argv, "tcrhSRCMPs:m:b:v:o:")) != EOF) {
  		switch(c) {
  		case 's':
  			if ((user.opt.solution=atoi(util_optarg)) > 3)
diff -r -c sis-1.2/vst2blif/vst2blif.c /projects/sis/sis-devel/common/src/vst2blif/vst2blif.c
*** sis-1.2/vst2blif/vst2blif.c	Sat Jun 25 18:34:26 1994
--- /projects/sis/sis-devel/common/src/vst2blif/vst2blif.c	Fri Oct 14 11:58:15 1994
***************
*** 1,47 ****
! static char rcsid[] = "$Id: vst2blif.c,v 0.28 1994/05/09 10:17:42 archiadm Exp $";
! static char build_date[] = "9 May 94";
  /*
!  * $Header: /home/cad00/users/archiadm/.Master/Filter/vst2blif.c,v 0.28 1994/05/09 10:17:42 archiadm Exp $
!  * $Revision: 0.28 $
!  * $Source: /home/cad00/users/archiadm/.Master/Filter/vst2blif.c,v $
!  * $Log: vst2blif.c,v $
!  * Revision 0.28  1994/05/09  10:17:42  archiadm
!  * alcuni ritocchi qua' e la'
   *
-  * Revision 0.27  1994/05/06  15:45:16  Rob
-  * rimesso a posto l'help iniziale con l'aggiunta dell'id
-  *
-  * Revision 0.26  1994/04/20  17:26:02  blaurea1
-  * ...non ricordo cosa ho cambiato, forse l'exit alla fine... non ricordo
-  *
-  * Revision 0.25  1994/04/19  10:19:12  blaurea1
-  * aggiunta inizializzazione dei latch
-  *
-  * Revision 0.24  1994/04/19  08:14:40  blaurea1
-  * oooops mancava l'exit dopo l'help
-  *
-  * Revision 0.23  1994/04/14  21:17:40  Rob
-  * aggiunti i $Log: vst2blif.c,v $
-  * Revision 0.28  1994/05/09  10:17:42  archiadm
-  * alcuni ritocchi qua' e la'
-  *
-  * Revision 0.27  1994/05/06  15:45:16  Rob
-  * rimesso a posto l'help iniziale con l'aggiunta dell'id
-  *
-  * Revision 0.26  1994/04/20  17:26:02  blaurea1
-  * ...non ricordo cosa ho cambiato, forse l'exit alla fine... non ricordo
-  *
-  * Revision 0.25  1994/04/19  10:19:12  blaurea1
-  * aggiunta inizializzazione dei latch
-  *
-  * Revision 0.24  1994/04/19  08:14:40  blaurea1
-  * oooops mancava l'exit dopo l'help
-  *.. => vedi precedente revisione
-  *
-  *
-  *    Vst2Blif   version 0.0
   *    BY rAMBALDI rOBERTO.
-  *       Feb. 25 1994.
   */
  
  #include <stdio.h>
--- 1,15 ----
! static char rcsid[] = "$Id$";
! #ifndef DATE
! #define DATE "Compile date not supplied"
! #endif
! static char build_date[] = DATE;
  /*
!  * $Header$
!  * $Revision$
!  * $Source$
!  * $Log$
   *
   *    BY rAMBALDI rOBERTO.
   */
  
  #include <stdio.h>
***************
*** 66,72 ****
   *           code         40 41 42 43 44   58 59 60 61 62      */
  #define isSTK(c) (( ((c)=='[') || ((c)==']') || ((c)=='|') || ((c)=='#') || \
  		    ( ((c)>=':') && ((c)<='>') ) || \
! 		    ( ((c)>='(') && ((c)<=',') ) ))
  #define isBLK(c) ( (((c)=='\t') || ((c)==' ') || ((c)=='\r')) )
  #define isREM(c) ( ((c)=='-') )
  #define isDQ(c)  ( ((c)=='"') )
--- 34,40 ----
   *           code         40 41 42 43 44   58 59 60 61 62      */
  #define isSTK(c) (( ((c)=='[') || ((c)==']') || ((c)=='|') || ((c)=='#') || \
  		    ( ((c)>=':') && ((c)<='>') ) || \
! 		    ( ((c)>='(') && ((c)<=',') ) ||  ((c)=='&') ))
  #define isBLK(c) ( (((c)=='\t') || ((c)==' ') || ((c)=='\r')) )
  #define isREM(c) ( ((c)=='-') )
  #define isDQ(c)  ( ((c)=='"') )
***************
*** 76,82 ****
  
  
  /* structure that contains all the info extracted from the library *
!  * All the pins, input, output and clock (if needed)               *
   * This because SIS should be case sensitive and VHDL is case      *
   * insensitive, so we must keep the library's names of gates and   *
   * pins. In the future this may be useful for further checks that  *
--- 44,50 ----
  
  
  /* structure that contains all the info extracted from the library *
!  * All the pins, input, outp[ut and clock (if needed)              *
   * This because SIS should be case sensitive and VHDL is case      *
   * insensitive, so we must keep the library's names of gates and   *
   * pins. In the future this may be useful for further checks that  *
***************
*** 85,139 ****
  /* list of inputs */
  struct PortName{
      char             name[MAXNAMELEN];
!     int             notused;  /* this flag is used to check if a  *
  				* formal terminal has been already *
  				* connected.                       */
      struct PortName  *next;
  };
  
! /* main structure */    
  struct Cell {
      char            name[MAXNAMELEN];
!     struct PortName *output;
!     struct PortName *inputs;
!     struct PortName *clock;
!     struct Cell     *next;
  };
  
  
  
! /* list of formal-names, is used in GetPort when multiple   *
!  * definition are gives, as    a,b,c : IN BIT;              */
! struct formals {
      char   name[MAXNAMELEN];
!     int   last;
!     struct formals *next;
  };
  
! /* list of the conections in a single instance, the first   *
!  * element should be the output port                        */
! struct connections {
!     char   formal[MAXNAMELEN];
!     char   actual[MAXNAMELEN];
!     struct connections *next;
  };
  
  
  FILE *In;
  FILE *Out;
  int  line;            /* line parsed                         */
  
  int SendTokenBack;   /* Used to send the token back to the  *
                         * input stream in case of a missing   *
                         * keyword,                            */
! char VDD[MAXNAMELEN]={ 0 },VSS[MAXNAMELEN]={ 0 },CLOCK[MAXNAMELEN]={ 0 };
! int DEBUG;
! int LOWERCASE;
! int INIT;
! int LINKAGE;
  struct Cell *cells;
  
  
  /* -=[ CloseAll ]=-                                 *
   * Closes all the files and flushes the used memory *
   *		                                    */
--- 53,155 ----
  /* list of inputs */
  struct PortName{
      char             name[MAXNAMELEN];
!     int              notused;  /* this flag is used to check if a  *
  				* formal terminal has been already *
  				* connected.                       */
      struct PortName  *next;
  };
  
! 
! struct Ports{
!     char   name[MAXNAMELEN];
! };
! 
  struct Cell {
+     char             name[MAXNAMELEN];
+     int              npins;
+     char             type;
+     struct SIGstruct *io;
+     struct Ports     *formals;
+     struct Cell      *next;
+ };
+ 
+ struct LibCell {
+     char           name[MAXNAMELEN];
+     int            npins;
+     char           clk[MAXNAMELEN];
+     struct Ports   *formals;
+     struct LibCell *next;
+ };
+ 
+ struct Instance {
      char            name[MAXNAMELEN];
!     struct Cell     *what;
!     struct Ports    *actuals;
!     struct Instance *next;
  };
+ 	
  
+ struct BITstruct {
+    char   name[MAXNAMELEN+10];
+    char   dir;
+    struct BITstruct *next;
+ };
  
  
! struct SIGstruct {
!     char name[MAXNAMELEN];
!     char dir;
!     int  start;
!     int  end;
!     struct SIGstruct *next;
! };
! 
! 
! struct TERMstruct {
      char   name[MAXNAMELEN];
!     int    start;
!     int    end;
  };
  
! struct ENTITYstruct {
!     char   name[MAXNAMELEN];
!     struct Cell        *Components;
!     struct Cell        *EntityPort;
!     struct SIGstruct   *Internals;
!     struct Instance    *Net;
  };
  
  
+ struct LibCell *ScanLibrary();
+ 
  FILE *In;
  FILE *Out;
+ struct LibCell *LIBRARY;
  int  line;            /* line parsed                         */
  
  int SendTokenBack;   /* Used to send the token back to the  *
                         * input stream in case of a missing   *
                         * keyword,                            */
! char VDD[MAXNAMELEN]={ 0 };
! char VSS[MAXNAMELEN]={ 0 };
! int  INIT;
! int  LINKAGE;
! int  LOWERCASE;
! char CLOCK[MAXNAMELEN];
! int  WARNING;
! int  INSTANCE;
  struct Cell *cells;
  
  
+ /*===========================================================================*
+ 
+   Utilities.
+   CloseAll   : closes all the files ads flushes the memory
+   Error      : display an error message an then exit
+   KwrdCmp    : compares keywords --> case insensitive
+ 
+  *===========================================================================*/
+ 
  /* -=[ CloseAll ]=-                                 *
   * Closes all the files and flushes the used memory *
   *		                                    */
***************
*** 140,151 ****
  void CloseAll()
  {
  
!     if (In!=stdin) (void) fclose(In);
!     if (Out!=stdout) (void) fclose(Out);
  
      free(cells);
  
! };
  
  
  /* -=[ Error ]=-                                    *
--- 156,167 ----
  void CloseAll()
  {
  
!     if (In!=stdin) (void)fclose(In);
!     if (Out!=stdout) (void)fclose(Out);
  
      free(cells);
  
! }
  
  
  /* -=[ Error ]=-                                    *
***************
*** 156,175 ****
  void Error(Msg)
  char *Msg;
  {
!     (void) fprintf(stderr,"*** Error : %s\n",Msg);
      CloseAll();
      exit(1);
! };
  
  /* -=[ KwrdCmp ]=-                                  *
   * Compares to strings, without taking care of the  *
   * case.                                            *
   *                                                  *
!  * Input :                                          *
!  *      name = first string, typically the token    *
!  *      keywrd = second string, typically a keyword *
   * Output :                                         *
!  *      char = 1 if the string matches            *
   *              0 if they don't match               */
  int KwrdCmp(name,keywrd)
  char *name;
--- 172,191 ----
  void Error(Msg)
  char *Msg;
  {
!     (void)fprintf(stderr,"*** Error : %s\n",Msg);
      CloseAll();
      exit(1);
! }
  
  /* -=[ KwrdCmp ]=-                                  *
   * Compares to strings, without taking care of the  *
   * case.                                            *
   *                                                  *
!  * Inoput :                                         *
!  *      name = first string, tipically the token    *
!  *      keywrd = second string, tipically a keyword *
   * Output :                                         *
!  *      int  = 1 if the strings matches            *
   *              0 if they don't match               */
  int KwrdCmp(name,keywrd)
  char *name;
***************
*** 186,466 ****
  	if (toupper(*name)!=toupper(*keywrd))
  	    return 0;
  	/* EoL, exit */
! 	if (*name=='\0') break;
!     };
      return 1;
  }
  
- 
- /* -=[ GetLibToken ]=-                              *
-  * Tokenizer to scan the library file               *
-  *                                                  *
-  * Input  :                                         *
-  *      Lib = library file                          *
-  * Output :                                         *
-  *      tok = filled with the new token             */
- void GetLibToken(Lib,tok)
- FILE *Lib;
- char *tok;
- {
-     enum states { tZERO, tLONG, tEOF, tSTRING };
-     static enum states next;
-     static int init=0;
-     static int sentback;
-     static char TOKEN[MAXTOKENLEN];
-     static int str;
-     int   ready;
-     int    num;
-     char   *t;
-     int   c;
- 
-     if (!init){
- 	sentback=0;
- 	init=1;
- 	next=tZERO;
- 	str=0;
-     };
- 
-     t= &(TOKEN[0]);
-     num=0;
-     str=0;
- 
-     do{
- 	if (sentback){
- 	    c=sentback;
- 	} else {
- 	    c=fgetc(Lib);
- 	};
- 	if (feof(Lib)) next=tEOF;
- 	ready=0;
- 	sentback='\0';
- 
- 	switch (next) {
- 	  case tZERO:
- 	    if ((c==' ') || (c=='\r') || (c=='\t')){
- 		next=tZERO;
- 	    } else {
- 		if ( ((c>=0x27) && (c<=0x2b)) || (c=='=') || (c==';') || (c=='\n') || (c=='!')){
- 		    *t=c; t++;
- 		    next=tZERO;
- 		    ready=1;
- 		} else {
- 		    if (c=='"') {
- 			num=0;
- 			next=tSTRING;
- 		    } else
- 			{
- 			    num=0;
- 			    next=tLONG;
- 			    ready=0;
- 			    sentback=c;
- 			};
- 		};
- 	    };
- 	    break;
- 	  case tLONG:
- 	    if ((c==' ') || (c=='\r') || (c=='\t')){
- 		ready=1;
- 		next=tZERO;
- 	    } else {
- 		if ( ((c>=0x27) && (c<=0x2b)) || (c=='=') || (c==';') || (c=='\n') || (c=='!')){
- 		    next=tZERO;
- 		    ready=1;
- 		    sentback=c;
- 		} else {
- 		    if (c=='"') {
- 			ready=1;
- 			next=tSTRING;
- 		    } else {
- 			*t=c;
- 			t++; num++;
- 			next=tLONG;
- 			if ( (ready=(num>=MAXTOKENLEN-1)) )
- 			    (void) fprintf(stderr,"Sorry, exeeded max name len of %u",num+1);
- 		    };
- 		};
- 		    
- 	    };
- 	    break;
- 	  case tSTRING:
- 	    if (!str) {
- 		*t='"'; t++; num++;
- 		str=1;
- 	    };
- 	    *t=c; t++; num++;
- 	    if (c=='"') {   /* last dblquote */
- 		ready=1;
- 		next=tZERO;
- 		break;
- 	    };
- 	    next=tSTRING;
- 	    if ( (ready=(num>=MAXTOKENLEN-1)) )
- 		(void) fprintf(stderr,"Sorry, exeeded max name len of %u",num+1);
- 	    break;
- 	  case tEOF:
- 	    next=tEOF;
- 	    ready=1;
- 	    sentback=c;
- 	    *t=c;
- 	  default :
- 	      next=tZERO;
- 	};
-     } while(!ready);
-     *t='\0';
-     (void) strcpy(tok,&(TOKEN[0]));
- };
- 
- /* -=[ IsValidInput ]=-                             *
-  * Check is a name has been already used in the     *
-  * expression. Here we look only at names, 'unused' * 
-  * flag here is not useful.                         *
-  *                                                  *
-  * Input  :                                         *
-  *     pins = pointer to list of formals            *
-  *     name = name to check                         *
-  * Output :                                         *
-  *     1 = if 'name' is not used                    *
-  *     0 = if used                                  */
- int IsValidInput(pins,name)
- struct PortName *pins;
- char *name;
- {
-     
-     while(pins!=NULL){
- 	/* We *MUST* use KwrdCmp because VHDL is *NOT* case sensitive */
- 	if (KwrdCmp(pins->name,name)){
- 	    return 0;
- 	};
- 	pins=pins->next;
-     };
-     return 1;
- }
- 
- 
- /* -=[ ScanLibrary ]=-                              *
-  * Scans the library to get the names of the cells  *
-  * the output pins and the clock signals of latches *
-  *                                                  *
-  * Input :                                          *
-  *     LibName = the name of library file           */
- void ScanLibrary(LibName)
- char *LibName;
- {
-     FILE *Lib;
-     struct Cell *pC;
-     struct PortName *pPN;
-     char LocalToken[MAXTOKENLEN];
-     char tmp[MAXNAMELEN];
-     int firstPN;
-     int firstC;
-     int latch;
-     int IsCell;
-     char *s;
-     
- 
-     if ((Lib=fopen(LibName,"rt"))==NULL)
- 	Error("Couldn't open library file");
- 
- 
-     s= &(LocalToken[0]);
-     firstC=1;
-     latch=0; IsCell=0;
-     (void) fseek(Lib,0,SEEK_SET);
-     if ( (cells=(struct Cell *)calloc(1, sizeof(struct Cell)) ) == NULL) 
- 	Error("Allocation error not enought memory !");
-     do {
- 	GetLibToken(Lib,s);
- 	if (KwrdCmp(s,"GATE")) {
- 	    if (latch) {
-                 (void) fprintf(stderr,"No CONTROL keyword for %s latch\n",pC->name);
-                 Error("Could not continue");
-             };
- 	    latch=0;
- 	    IsCell=1;
- 	} else {
- 	    if (KwrdCmp(s,"LATCH")) {
- 		if (latch) {
- 		    (void) fprintf(stderr,"No CONTROL keyword for %s latch\n",pC->name);
- 		    Error("Could not continue");
- 		};
- 		IsCell=1;
- 		latch=1;
- 	    } else {
-                 if (KwrdCmp(s,"CONTROL")) {
-                     latch=0;
- 		    if ( (pC->clock=(struct PortName *)calloc(1, sizeof(struct PortName)) ) == NULL) 
- 			Error("Allocation error not enought memory !");
- 		    (pC->clock)->next=NULL;
- 		    /* get name of control signal */
- 		    GetLibToken(Lib,s);
-                     (void) strncpy((pC->clock)->name,s,MAXNAMELEN);
-                 };
- 		
- 	    };
- 	};
- 	if (IsCell) {
- 	    if (firstC) {
- 		pC=cells;
- 		firstC=0;
- 	    } else {
- 		if ( (pC->next=(struct Cell *)calloc(1, sizeof(struct Cell)) ) == NULL) 
- 		    Error("Allocation error not enought memory !");
- 		pC=pC->next;
- 	    };
- 
- 	    /* name */
- 	    GetLibToken(Lib,s);
- 	    (void) strncpy(pC->name,s,MAXNAMELEN);
- 
- 	    /* skip Area */
- 	    GetLibToken(Lib,s);
- 
- 	    /* output */
- 	    GetLibToken(Lib,s);
- 	    if ( (pC->output=(struct PortName *)calloc(1, sizeof(struct PortName)) ) == NULL) 
- 		Error("Allocation error not enought memory !");
- 	    (pC->output)->next=NULL;
- 	    (pC->output)->notused=1;
- 	    (void) strncpy( (pC->output)->name ,s, MAXNAMELEN);
- 
- 	    /* get inputs */
- 	    firstPN=1;
- 	    do {
- 		GetLibToken(Lib,s);
- 		if ( !( ((*s>=0x27) && (*s<=0x2b)) || (*s=='=') || (*s=='!')|| (*s==';')) ){
- 		    (void) strncpy(tmp,s,5);
- 		    tmp[5] = '\0';
- 		    if (KwrdCmp(tmp,"CONST") && !isalpha(*(s+6)))
- 			/* if the expression has a constant value we must */
- 			/* skip it, because there are no inputs           */
- 			break;
- 		    /* it's an operand so get its name */
- 		    if (IsValidInput(pC->inputs,s)) {
- 			/* only if it was not used in this expression */
- 			if (firstPN){
- 				if ( (pC->inputs=(struct PortName *)calloc(1, sizeof(struct PortName)) ) == NULL) 
- 				Error("Allocation error not enought memory !");
- 			    pPN=pC->inputs;
- 			    firstPN=0;
- 			} else {
- 			    if ( (pPN->next=(struct PortName *)calloc(1, sizeof(struct PortName)) ) == NULL) { 
- 				Error("Allocation error not enought memory !");
- 			    };
- 			    pPN=pPN->next;
- 			    pPN->next=NULL;
- 			};
- 			(void) strncpy(pPN->name,s,MAXNAMELEN);
- 			pPN->notused=1;
- 		    };
- 		};
- 	    } while ( (*s!=';') );
- 	    IsCell=0;
- 	};
-     } while (!feof(Lib));
- };
- 
- 
- 
  /* -=[ CheckArgs ]=-                                *
   * Gets the options from the command line, open     *
   * the input and output file and read params from   *
--- 202,212 ----
  	if (toupper(*name)!=toupper(*keywrd))
  	    return 0;
  	/* EoL, exit */
! 	if (*keywrd=='\0') break;
!     }
      return 1;
  }
  
  /* -=[ CheckArgs ]=-                                *
   * Gets the options from the command line, open     *
   * the input and output file and read params from   *
***************
*** 472,597 ****
  int  argc;
  char **argv;
  {
-     int c;
-     int help;
      char *s;
      int NoPower;
  
      extern char *optarg;
      extern int optind;
  
!     (void) fprintf(stderr,"\t\t         Vst2Blif v1.0\n");
!     (void) fprintf(stderr,"\t\t      by Roberto Rambaldi\n");
!     (void) fprintf(stderr,"\t\tD.E.I.S. Universita' di Bologna\n\n");
!     help=0; NoPower=0; LINKAGE='i';
!     LOWERCASE=1; INIT='3';
      while( (c=getopt(argc,argv,"s:S:d:D:c:C:i:I:l:L:hHvVuUnN$") )>0 ){
! 	switch (toupper(c)) {
! 	  case 'S':
! 	    (void) strncpy(VSS,optarg,MAXNAMELEN);
! 	    break;
! 	  case 'D':
! 	    (void) strncpy(VDD,optarg,MAXNAMELEN);
! 	      break;
! 	  case 'V':
! 	    DEBUG=1;
! 	    break;
! 	  case 'H':
! 	    help=1;
! 	    break;
! 	  case 'C':
! 	    (void) strncpy(CLOCK,optarg,MAXNAMELEN);
! 	    break;
! 	  case 'I':
! 	    INIT= *optarg;
! 	    if ((INIT<'0') || (INIT>'3')) {
! 		(void) fprintf(stderr,"Wrong latch init value");
! 		help=1;
! 	    };
! 	    break;
! 	  case 'L':
! 	    if (KwrdCmp(optarg,"IN")) {
! 		LINKAGE='i';
! 	    } else {
! 		if  (KwrdCmp(optarg,"OUT")) {
! 		    LINKAGE='o';
! 		} else {
! 		    (void) fprintf(stderr,"\tUnknow direction for a port of type linkage\n");
! 		    help=1;
! 		};
! 	    };
! 	    break;
! 	  case 'U':
! 	    LOWERCASE=0;
! 	    break;
! 	  case 'N':
! 	    NoPower=1;
! 	    break;
! 	  case '$':
! 	    help=1;
! 	    (void) fprintf(stderr,"\n\tID = %s\n",rcsid);
! 	    (void) fprintf(stderr,"\tCompiled on %s\n\n",build_date);
! 	    break;
! 	};
!     };	    
  
  
      if (!help) {
! 	if (LOWERCASE) 
! 	    for(s= &(CLOCK[0]); *s!='\0'; s++) tolower(*s);
! 	else 
! 	    for(s= &(CLOCK[0]); *s!='\0'; s++) toupper(*s);
  	
! 	if (optind>=argc) {
! 	    (void) fprintf(stderr,"No Library file specified\n\n");
! 	    help=1;
! 	} else {
! 	    ScanLibrary(argv[optind]);
! 	    if (++optind>=argc){
! 		In=stdin; Out=stdout;
! 	    } else {
! 		if ((In=fopen(argv[optind],"rt"))==NULL) {
! 		    (void) fprintf(stderr,"Couldn't read input file");
! 		    help=1;
! 		};
! 		if (++optind>=argc) { Out=stdout; }
! 		else {
! 		    if ((Out=fopen(argv[optind],"wt"))==NULL) {
! 			(void) fprintf(stderr,"Could'n make opuput file");
! 			help=1;
! 		    };
! 		};
! 	    };
! 	};
! 	
! 	if (NoPower) {
! 	    VDD[0]='\0'; VSS[0]='\0';
! 	} else {
! 	    if (VDD[0]=='\0') (void) strcpy(VDD,"VDD");
! 	    if (VSS[0]=='\0') (void) strcpy(VSS,"VSS");
! 	};
!     };
! 	
      if (help) {
! 	(void) fprintf(stderr,"\tUsage: vst2blif [options] <library> [infile [outfile]]\n");
! 	(void) fprintf(stderr,"\t\t if outfile is not given stdout will be used, if infile\n");
! 	(void) fprintf(stderr,"\t\t is also not given stdin will be used instead.\n");
! 	(void) fprintf(stderr,"\t<library>\t is the name of the library file to use\n");
! 	(void) fprintf(stderr,"\tOptions :\n\t-s <name>\t <name> will be used for VSS net\n");
! 	(void) fprintf(stderr,"\t-d <name>\t <name> will be used for VDD net\n");
! 	(void) fprintf(stderr,"\t-c <name>\t .clock <name>  will be added to the blif file\n");
! 	(void) fprintf(stderr,"\t-i <value>\t default value for latches, must be between 0 and 3\n");
! 	(void) fprintf(stderr,"\t-l <in/out>\t sets the direction for linkage ports\n");
! 	(void) fprintf(stderr,"\t\t\t the default value is \"in\"\n");
!         (void) fprintf(stderr,"\t-u\t\t converts all names to uppercase\n");
! 	(void) fprintf(stderr,"\t-n\t\t no VSS or VDD to skip.\n");
! 	(void) fprintf(stderr,"\t-h\t\t prints these lines");
! 	(void) fprintf(stderr,"\n\tIf no VDD or VSS nets are given VDD and VSS will be used\n");
! 	exit(0);
!     };
! };
  
- 
  /* -=[ GetNextToken ]=-                             *
   * Tokenizer, see the graph to understand how it    *
   * works.                                           *
--- 218,341 ----
  int  argc;
  char **argv;
  {
      char *s;
+     char c;
+     int help;
      int NoPower;
  
      extern char *optarg;
      extern int optind;
  
!     s=&( argv[0][strlen(argv[0])-1] );
!     while( (s>= &(argv[0][0])) && (*s!='/') ) {  s--; }
!      
!     (void)fprintf(stderr,"\t\t      Vst Converter v1.5\n");
!     (void)fprintf(stderr,"\t\t      by Roberto Rambaldi\n");
!     (void)fprintf(stderr,"\t\tD.E.I.S. Universita' di Bologna\n\n");
!     help=0;  INSTANCE=1; NoPower=0; LOWERCASE=1; INIT='3';
      while( (c=getopt(argc,argv,"s:S:d:D:c:C:i:I:l:L:hHvVuUnN$") )>0 ){
!         switch (toupper(c)) {
!           case 'S':
!             (void)strncpy(VSS,optarg,MAXNAMELEN);
!             break;
!           case 'D':
!             (void)strncpy(VDD,optarg,MAXNAMELEN);
!               break;
!           case 'H':
!             help=1;
!             break;
!           case 'C':
!             (void)strncpy(CLOCK,optarg,MAXNAMELEN);
!             break;
!           case 'I':
!             INIT= *optarg;
!             if ((INIT<'0') || (INIT>'3')) {
!                 (void)fprintf(stderr,"Wrong latch init value");
!                 help=1;
!             }
!             break;
!           case 'L':
!             if (KwrdCmp(optarg,"IN")) {
!                 LINKAGE='i';
!             } else {
!                 if  (KwrdCmp(optarg,"OUT")) {
!                     LINKAGE='o';
!                 } else {
! 		    (void)fprintf(stderr,"\tUnknow direction for a port of type linkage\n");
!                     help=1;
!                 }
!             }
!             break;
!           case 'U':
!             LOWERCASE=0;
!             break;
!           case 'N':
!             NoPower=1;
!             break;
!           case '$':
!             help=1;
!             (void)fprintf(stderr,"\n\tID = %s\n",rcsid);
!             (void)fprintf(stderr,"\tCompiled on %s\n\n",build_date);
!             break;
!         }
!     }     
  
  
      if (!help) {
!         if (LOWERCASE) 
!             for(s=&(CLOCK[0]); *s!='\0'; s++) (void)tolower(*s);
!         else 
!             for(s=&(CLOCK[0]); *s!='\0'; s++) (void)toupper(*s);
! 
!         if (optind>=argc) {
!             (void)fprintf(stderr,"No Library file specified\n\n");
!             help=1;
!         } else {
!             LIBRARY=(struct LibCell *)ScanLibrary(argv[optind]);
!             if (++optind>=argc){
!                 In=stdin; Out=stdout;
!             } else {
!                 if ((In=fopen(argv[optind],"rt"))==NULL) {
!                     (void)fprintf(stderr,"Couldn't read input file");
!                     help=1;
!                 }
!                 if (++optind>=argc) { Out=stdout; }
!                 else {
!                     if ((Out=fopen(argv[optind],"wt"))==NULL) {
!                         (void)fprintf(stderr,"Could'n make opuput file");
!                         help=1;
!                     }
!                 }
!             }
!         }
  	
!         if (NoPower) {
!             VDD[0]='\0'; VSS[0]='\0';
!         } else {
!             if (!VDD[0]) (void)strcpy(VDD,"VDD");
!             if (!VSS[0]) (void)strcpy(VSS,"VSS");
!         }
!     }
! 
      if (help) {
!         (void)fprintf(stderr,"\tUsage: vst2blif [options] <library> [infile [outfile]]\n");
!         (void)fprintf(stderr,"\t\t if outfile is not given will be used stdout, if also\n");
!         (void)fprintf(stderr,"\t\t infile is not given will be used stdin instead.\n");
!         (void)fprintf(stderr,"\t<library>\t is the name of the library file to use\n");
!         (void)fprintf(stderr,"\tOptions :\n\t-s <name>\t <name> will be used for VSS net\n");
!         (void)fprintf(stderr,"\t-d <name>\t <name> will be used for VDD net\n");
!         (void)fprintf(stderr,"\t-c <name>\t .clock <name>  will be added to the blif file\n");
!         (void)fprintf(stderr,"\t-i <value>\t default value for latches, must be between 0 and 3\n");
!         (void)fprintf(stderr,"\t-l <in/out>\t sets the direction for linkage ports\n");
!         (void)fprintf(stderr,"\t\t\t the default value is \"in\"\n");
!         (void)fprintf(stderr,"\t-u\t\t converts all names to uppercase\n");
!         (void)fprintf(stderr,"\t-n\t\t no VSS or VDD to skip.\n");
!         (void)fprintf(stderr,"\t-h\t\t prints these lines");
!         (void)fprintf(stderr,"\n\tIf no VDD or VSS nets are given VDD and VSS will be used\n");
!         exit(0);
!     }
! }
  
  /* -=[ GetNextToken ]=-                             *
   * Tokenizer, see the graph to understand how it    *
   * works.                                           *
***************
*** 604,618 ****
  void GetNextToken(tok)
  char *tok;
  {
!     static int init=0;
      static enum TOKEN_STATES state;
!     static int sentback;
!     static int str;
      static char Token[MAXTOKENLEN];
      char   *t;
      int    num;
      int   TokenReady;
!     int   c;
      
      if (!init) {
  	state=tZERO;
--- 348,362 ----
  void GetNextToken(tok)
  char *tok;
  {
!     static char init=0;
      static enum TOKEN_STATES state;
!     static char sentback;
!     static char str;
      static char Token[MAXTOKENLEN];
      char   *t;
      int    num;
      int   TokenReady;
!     char   c;
      
      if (!init) {
  	state=tZERO;
***************
*** 619,627 ****
  	init=1;
  	line=0;
  	SendTokenBack=0;
!     };
  
!     t= &(Token[0]);
      num=0;
      TokenReady=0;
      str=0;
--- 363,371 ----
  	init=1;
  	line=0;
  	SendTokenBack=0;
!     }
  
!     t=&(Token[0]);
      num=0;
      TokenReady=0;
      str=0;
***************
*** 628,636 ****
  
      if (SendTokenBack) {
  	SendTokenBack=0;
! 	(void) strcpy(tok,Token);
  	return;
!     };
  
      do {
  	if (sentback) {
--- 372,380 ----
  
      if (SendTokenBack) {
  	SendTokenBack=0;
! 	(void)strcpy(tok,Token);
  	return;
!     }
  
      do {
  	if (sentback) {
***************
*** 639,645 ****
  	    c=fgetc(In);
  	    if (feof(In)) state=tEOF;
  	    if (c=='\n') line++;
! 	};
  
  	switch (state){
  	  case tZERO:
--- 383,389 ----
  	    c=fgetc(In);
  	    if (feof(In)) state=tEOF;
  	    if (c=='\n') line++;
! 	}
  
  	switch (state){
  	  case tZERO:
***************
*** 673,683 ****
  			    } else {
  				sentback=c;
  				state=tTOKEN;
! 			    };
! 			};
! 		    };
! 		};
! 	    };
  	    break;
  	  case tTOKEN:
              /*******************/
--- 417,427 ----
  			    } else {
  				sentback=c;
  				state=tTOKEN;
! 			    }
! 			}
! 		    }
! 		}
! 	    }
  	    break;
  	  case tTOKEN:
              /*******************/
***************
*** 706,727 ****
  				sentback='\0';
  				if (num>=(MAXTOKENLEN-1)){
  				    sentback=c;
! 				    (void) fprintf(stderr,"*Parse Warning* Line %u: token too long !\n",line);
! 				} else {
! 				    if (LOWERCASE)
! 					*t=tolower(c);
! 				    else 
! 					*t=toupper(c);
  				    t++; num++;
  				    TokenReady=0;
  				    /* fprintf(stderr,"."); */
! 				};
  				state=tTOKEN;
! 			    };
! 			};
! 		    };
! 		};
! 	    };
  	    break;
  	  case tREM1:
              /*******************/
--- 450,469 ----
  				sentback='\0';
  				if (num>=(MAXTOKENLEN-1)){
  				    sentback=c;
! 				    (void)fprintf(stderr,"*Parse Warning* Line %u: token too long !\n",line);
! 				} else {                                    
! 				    if (LOWERCASE) *t=tolower(c);
!                                     else *t=toupper(c);
  				    t++; num++;
  				    TokenReady=0;
  				    /* fprintf(stderr,"."); */
! 				}
  				state=tTOKEN;
! 			    }
! 			}
! 		    }
! 		}
! 	    }
  	    break;
  	  case tREM1:
              /*******************/
***************
*** 752,762 ****
  				state=tZERO;
  			    } else {
  				state=tTOKEN;
! 			    };
! 			};
! 		    };
! 		};
! 	    };
  	    break;
  	  case tREM2:
              /*******************/
--- 494,504 ----
  				state=tZERO;
  			    } else {
  				state=tTOKEN;
! 			    }
! 			}
! 		    }
! 		}
! 	    }
  	    break;
  	  case tREM2:
              /*******************/
***************
*** 766,772 ****
  	    TokenReady=0;
  	    if isEOL(c) {
  		num=0;
! 		t= &(Token[0]);
  		state=tZERO;
  	    } else {
  		if isEOF(c) {
--- 508,514 ----
  	    TokenReady=0;
  	    if isEOL(c) {
  		num=0;
! 		t=&(Token[0]);
  		state=tZERO;
  	    } else {
  		if isEOF(c) {
***************
*** 775,782 ****
  		    TokenReady=0;
  		} else {
  		    state=tREM2;
! 		};
! 	    };
  	    break;
  	  case tSTRING:
              /*******************/
--- 517,524 ----
  		    TokenReady=0;
  		} else {
  		    state=tREM2;
! 		}
! 	    }
  	    break;
  	  case tSTRING:
              /*******************/
***************
*** 785,791 ****
  	    if (!str) {
  		*t='"'; t++; num++; /* first '"' */
  		str=1;
! 	    };
  	    sentback='\0';
  	    TokenReady=1;
  	    if isDQ(c) {
--- 527,533 ----
  	    if (!str) {
  		*t='"'; t++; num++; /* first '"' */
  		str=1;
! 	    }
  	    sentback='\0';
  	    TokenReady=1;
  	    if isDQ(c) {
***************
*** 796,851 ****
  		if isEOF(c) {
  		    state=tEOF;    /* this is *UNESPECTED* ! */
  		    sentback=1;
! 		    (void) fprintf(stderr,"*Parse Warning* Line %u: unespected Eof\n",line);
  		} else {
  		    sentback='\0';
  		    if (num>=MAXTOKENLEN-2){
  			sentback=c;
! 			(void) fprintf(stderr,"*Parse Warning* Line %u: token too long !\n",line);
! 		    } else {
! 			*t=c; t++; num++;
  			TokenReady=0;
  			state=tSTRING;
! 		    };
! 		};
! 	    };
  	    break;
  	  case tEOF:
              /*******************/
  	    /*    EOF  state   */
              /*******************/
! 	    t= &(Token[0]);
  	    TokenReady=1;
  	    state=tEOF;
  	    break;
! 	};
      } while(!TokenReady);
      *(t)='\0';
!     (void) strcpy(tok,Token);
      return ;
! };
  
  
! /* -=[ WhatGate ]=-                                 *
!  * Returns a pointer to an element of the list      *
!  * of gates that matches up the name given, if      *
!  * there isn't a match a null pointer is returned   *
!  *                                                  *
!  * Input :                                          *
!  *     name = name to match                         *
!  * Ouput :                                          *
!  *     (void *) a pointer                           */
! void *WhatGate(name)
! char *name;
  {
!     struct Cell  *ptr;
  
!     for(ptr=cells; ptr!=NULL ; ptr=ptr->next)
! 	if ( KwrdCmp(ptr->name,name) ) return (void *)ptr;
  
-     return (void *)NULL;
- };
  
  /* -=[ Warning ]=-                                  *
   * Puts a message on stderr, write the current line *
   * and then sends the current token back            *
--- 538,652 ----
  		if isEOF(c) {
  		    state=tEOF;    /* this is *UNESPECTED* ! */
  		    sentback=1;
! 		    (void)fprintf(stderr,"*Parse Warning* Line %u: unespected Eof\n",line);
  		} else {
  		    sentback='\0';
  		    if (num>=MAXTOKENLEN-2){
  			sentback=c;
! 			(void)fprintf(stderr,"*Parse Warning* Line %u: token too long !\n",line);
! 		    } else {                                
! 			if (LOWERCASE) *t=tolower(c);
! 			else *t=toupper(c);
! 			t++; num++;
  			TokenReady=0;
  			state=tSTRING;
! 		    }
! 		}
! 	    }
  	    break;
  	  case tEOF:
              /*******************/
  	    /*    EOF  state   */
              /*******************/
! 	    t=&(Token[0]);
  	    TokenReady=1;
  	    state=tEOF;
  	    break;
! 	}
      } while(!TokenReady);
      *(t)='\0';
!     (void)strcpy(tok,Token);
      return ;
! }
  
+ /*====================================================================*
  
! 
!   ReleaseBit : deallocates an entire BITstruct structure
!   ReleaseSIG : deallocates an entire SIGstruct structure
!   NewCell    : allocates memory for a new cell
! 
! 
!   ====================================================================*/
! 
! void ReleaseBit(ptr)
! struct BITstruct *ptr;
  {
!     struct BITstruct *tmp;
  
!     while(ptr!=NULL){
! 	tmp=ptr->next;
! 	free(ptr);
! 	ptr=tmp;
!     }
! }
  
  
+ void ReleaseSIG(ptr)
+ struct SIGstruct *ptr;
+ {
+     struct SIGstruct *tmp;
+ 
+     while(ptr!=NULL){
+ 	tmp=ptr->next;
+ 	free(ptr);
+ 	ptr=tmp;
+     }
+ }
+ 
+ 
+ 
+ void AddBIT(BITptr,name,dir)
+ struct BITstruct **BITptr;
+ char   *name;
+ char   dir;
+ {
+ 
+    (*BITptr)->next=(struct BITstruct *)calloc(1,sizeof(struct BITstruct));
+    if ( (*BITptr)->next==NULL) {
+ 	Error("Allocation Error or not enought memory !");
+     }
+    (*BITptr)=(*BITptr)->next;
+    (void)strcpy((*BITptr)->name,name);
+    (*BITptr)->dir=dir;
+    (*BITptr)->next=NULL;
+ }
+ 
+ void AddSIG(SIGptr,name,dir,start,end)
+ struct SIGstruct **SIGptr;
+ char   *name;
+ char   dir;
+ int    start;
+ int    end;
+ {
+ 
+    (*SIGptr)->next=(struct SIGstruct *)calloc(1,sizeof(struct SIGstruct));
+    if ( (*SIGptr)->next==NULL) {
+ 	Error("Allocation Error or not enought memory !");
+     }
+    (*SIGptr)=(*SIGptr)->next;
+    (void)strcpy((*SIGptr)->name,name);
+    (*SIGptr)->dir=dir;
+    (*SIGptr)->start=start;
+    (*SIGptr)->end=end;
+    (*SIGptr)->next=NULL;
+ #ifdef DEBUG
+    (void)fprintf(stderr,"\n\t\tAdded SIGNAL <%s>, dir = %c, start =%d, end =%d",(*SIGptr)->name,(*SIGptr)->dir,(*SIGptr)->start,(*SIGptr)->end);
+ #endif
+ }
+ 
+ 
+ 
  /* -=[ Warning ]=-                                  *
   * Puts a message on stderr, write the current line *
   * and then sends the current token back            *
***************
*** 855,867 ****
  void Warning(name)
  char *name;
  {
!     if (DEBUG) (void) fprintf(stderr,"*parse warning* Line %u : %s\n",line,name);
      SendTokenBack=1;
! };
  
  /* -=[ VstError ]=-                                 *
   * sends to stderr a message and then gets tokens   *
!  * until a given one is reached                     *
   *                                                  *
   * Input :                                          *
   *     name = message to print                      *
--- 656,668 ----
  void Warning(name)
  char *name;
  {
!     if (WARNING) (void)fprintf(stderr,"*parse warning* Line %u : %s\n",line,name);
      SendTokenBack=1;
! }
  
  /* -=[ VstError ]=-                                 *
   * sends to stderr a message and then gets tokens   *
!  * until a gicen one is reached                     *
   *                                                  *
   * Input :                                          *
   *     name = message to print                      *
***************
*** 873,881 ****
      char *w;
      char LocalToken[MAXTOKENLEN];
  
!     w= &(LocalToken[0]);
!     (void) fprintf(stderr,"*Error* Line %u : %s\n",line,name);
!     (void) fprintf(stderr,"*Error* Line %u : skipping text until the keyword %s is reached\n",line,next);
      SendTokenBack=1;
      do{
  	GetNextToken(w);
--- 674,682 ----
      char *w;
      char LocalToken[MAXTOKENLEN];
  
!     w=&(LocalToken[0]);
!     (void)fprintf(stderr,"*Error* Line %u : %s\n",line,name);
!     (void)fprintf(stderr,"*Error* Line %u : skipping text until the keyword %s is reached\n",line,next);
      SendTokenBack=1;
      do{
  	GetNextToken(w);
***************
*** 882,888 ****
  	if (feof(In))
  	    Error("Unespected Eof!");
      } while( !KwrdCmp(w,next) );
! };
  
  /* -=[ DecNumber ]=-                                *
   * checks if a token is a decimal number            *
--- 683,689 ----
  	if (feof(In))
  	    Error("Unespected Eof!");
      } while( !KwrdCmp(w,next) );
! }
  
  /* -=[ DecNumber ]=-                                *
   * checks if a token is a decimal number            *
***************
*** 901,1171 ****
  
      for(s=string; *s!='\0'; s++)
  	if (!isdigit(*s)) {
! 	    (void) sprintf(msg,"*Error Line %u : Expected decimal integer number \n",line);
  	    Error(msg);
! 	};
      return atoi(string);
! };
  
! /* -=[ GetVector ]=-                                *
!  * Gets the extremes of a vector definition         *
   *                                                  *
!  * Ouput :                                          *
!  *     frst : first element                         *
!  *     scnd : second element                        *
!  * :: BIT_VECTOR(7 DOWNTO 0) --> frst=7, scnd=0     *
!  *              (0 TO 7)     --> frst=0, scnd=7     */
! void GetVector(frst,scnd)
! int *frst;
! int *scnd;
  {
!     char *w;
!     char LocalToken[MAXTOKENLEN];
!     int vect_to;
!     int vect_down;
  
  
!     w= &(LocalToken[0]);
!     vect_to=0; vect_down=0;
  
!     /* start: */
!     GetNextToken(w);
!     if (*w!='(') Warning("expected '(' for vector size");
  
!     /* first number */
!     GetNextToken(w);
!     *frst=DecNumber(w);
  
!     /* Upward or downward ? */
!     GetNextToken(w);
!     vect_to=KwrdCmp(w,"TO");
!     vect_down=KwrdCmp(w,"DOWNTO");
!     if (!vect_to && !vect_down)
! 	Warning("expected kewords TO or DOWNTO for vector size");
  
!     /* second number */
!     GetNextToken(w);
!     *scnd=DecNumber(w);
  
  
!     if (*frst==*scnd) Warning("vector with no elements !?");
!     if (vect_to) {
! 	if (*frst>*scnd) Warning("used keyword TO instead of DOWNTO");
!     } else
! 	if (vect_down) {
! 	  if (*frst<*scnd) Warning("used keyword DOWNTO instead of TO");
!     };
!     SendTokenBack=0; /* I know that this is really bad, SendTokenBack     *
! 		      * should be used only by Warning() GetNextToken()   *
! 		      * and VstError() but ....                           *
! 		      * this way is quikly & simple ... :-)               */
  
!     /* closing ')' */
!     GetNextToken(w);
!     if (*w!=')') Warning("expected ')' for vector size");
  }
  
  
! /* -=[ PrintVector ]=-                              *
!  * Get the extremes of a vector and then expandes   *
!  * all of the elements.                             *
   *                                                  *
   * Input :                                          *
!  *     first = formals which have the same          *
!  *             definition                           *
!  *     flag  = for printing                         */
! void PrintVector(first,flag)
! struct formals *first;
! int flag;
  {
!     struct formals *ptr;
!     int  j;
!     int  frst;
!     int  scnd;
!     int tmp;
  
!     /* first get vector size */
!     GetVector(&frst,&scnd);
  
!     if (flag){
! 	ptr=first;
! 	do {
! 	/* Now let's print em */
! 	    if (frst<scnd) {
! 		for(j=frst; j<=scnd; j++)
! 		    (void) fprintf(Out,"%s(%u) ",ptr->name,j);
  	    } else {
! 		for(j=frst; j>=scnd; j--)
! 		    (void) fprintf(Out,"%s(%u) ",ptr->name,j);
! 	    };
! 	    tmp=ptr->last;
! 	    ptr=ptr->next;
! 	} while(tmp);
!     };
  }
  
! /* -=[ FreeFormals ]=-                             *
!  * Releases the memory used for parsing multiple   *
!  * declarations.                                   *
!  *                                                 *
!  * Input :                                         *
!  *     first = first element of the list, this     *
!  *             should *NOT* be released because    *
!  *             it is declared statically           */
! void FreeFormals(first)
! struct formals *first;
  {
!     struct formals *tmp;
!     struct formals *ptr;
  
!     ptr=first->next;
!     if (ptr==NULL) return;
!     for (; ptr!=NULL; ) {
! 	tmp=ptr->next;
! 	free(ptr);
! 	ptr=tmp;
!     };
! };
  
  /* -=[ GetPort ]=-                                 *
   * Gets the port definition of an ENTITY or of a   *
   * COMPONENT.                                      *
!  *                                                 *
!  * Input :                                         *
!  *     flag = 1 for the ENTITY                     *
!  *            0 for the COMPONENT                  */
! void GetPort(flag)
! int flag;
  {
!     struct formals first;
!     struct formals *ptr;
      char *w;
      char LocalToken[MAXTOKENLEN];
!     int dir;
!     int dir2;
!     int alim;
!     int tmp;
  
  
-     w= &(LocalToken[0]);
-     first.next=NULL;
- 
      GetNextToken(w);
      if ( *w!='(' ) Warning("expected '('");
  
!     dir = '\0'; alim='\0';
      do{
  	/* name of the port */
! 	GetNextToken(w);
! 	(void) strcpy(first.name,w);
! 	first.last=1;
! 	alim= (KwrdCmp(w,VDD) || KwrdCmp(w,VSS) || KwrdCmp(w,CLOCK) );
! 	/* multiple definition */
! 	ptr= &first;
! 	do {
  	    GetNextToken(w);
! 	    if (*w==':') {
! 		ptr->last=0;
! 		break;
! 	    };
! 	    if (*w!=',') {
! 		FreeFormals(&first);
! 		VstError("expected ':' or ',' after identifier",";");
! 	    };
! 	    /* next formal name */
  	    GetNextToken(w);
  
! 	    if (flag && !(KwrdCmp(w,VDD) || KwrdCmp(w,VSS) || KwrdCmp(w,CLOCK))) {
! 		if (ptr->next==NULL) {
! 		    if ( (ptr->next=(struct formals *)calloc(1,sizeof(struct formals)))==NULL ){
! 			FreeFormals(&first);
! 			Error("Allocation error or not enought memory");
! 		    };
! 		    (ptr->next)->next=NULL;
! 		};
! 		ptr=ptr->next;
! 		(void) strcpy(ptr->name,w);
! 		ptr->last=1;
! 	    };
! 	} while (1);
  
! 	/* direction: in,out,inout */
! 	GetNextToken(w);
! 	if (KwrdCmp(w,"IN")){
! 	    dir2='i';
! 	} else {
! 	    if (KwrdCmp(w,"OUT")) {
! 		dir2='o';
! 	    } else {
! 		if (KwrdCmp(w,"LINKAGE")) {
! 		    dir2=LINKAGE;
  		} else {
! 		    if (KwrdCmp(w,"INOUT")){
! 			(void) fprintf(stderr,"* Error * Line %u : input/output ports not supported\n",line);
! 			Error("Could not continue");
  		    } else {
! 			(void) fprintf(stderr,"* Error * Line %u : unknown direction of a port\n",line);
! 			Error("Could not continue");
! 		    };
! 		};
! 	    };
! 	};
  
! 	/* If the direction changed print a new line */
! 	if (flag && !(alim && !first.last)) {
! 	    if (dir!=dir2){
! 		if (dir2=='i') (void) fprintf(Out,"\n.inputs ");
! 		else (void) fprintf(Out,"\n.outputs ");
! 	    };
! 	    dir=dir2;
! 	};
  
- 	/* type: bit, bit_vector */
- 	GetNextToken(w);
- 	if (KwrdCmp(w,"BIT")) {
- 	    if (flag && !(alim && !first.last)) {
- 		ptr= &first;
- 		do {
- 		    (void) fprintf(Out,"%s ",ptr->name);
- 		    tmp=ptr->last;
- 		    ptr=ptr->next;
- 		} while (tmp);
- 	    };
- 	} else {
- 	    /* Now let's look at vectors */
- 	    if (KwrdCmp(w,"BIT_VECTOR")) {
- 		if (!flag) {
- 		    Error("Sorry, but vectors in library gates are not allowed !\n");
- 		};
- 		/* vector of bits */
- 		PrintVector(&first,flag);
- 	    } else {
- 		(void) fprintf(stderr,"* Error * Line %u : Unknown type of signal : %s \n",line,w);
- 		Error("Could not continue");
- 	    };
- 	};
- 	GetNextToken(w);
- 	if (*w==')') break;
- 	if (*w!=';') {
- 	    VstError("expected ';' or ')'","END");
- 	    FreeFormals(&first);
- 	    return;
- 	};
-     } while(1);
-     GetNextToken(w);
-     if (*w!=';') Warning("extected ';'");
-     if (flag) {
- 	if (CLOCK[0])
- 	    (void) fprintf(Out,"\n.clock %s",CLOCK);
- 	(void) fprintf(Out,"\n\n");
- 	FreeFormals(&first);
-     };
- };
  
- 
  /* -=[ GetEntity ]=-                                *
   * parses the entity statement                      */
! void GetEntity()
  {
      char *w;
      char LocalToken[MAXTOKENLEN];
--- 702,1502 ----
  
      for(s=string; *s!='\0'; s++)
  	if (!isdigit(*s)) {
! 	    (void)sprintf(msg,"*Error Line %u : Expected decimal integer number \n",line);
  	    Error(msg);
! 	}
      return atoi(string);
! }
  
! 
! /*=========================================================================*
! 
! 
!   Genlib scan
!   ^^^^^^^^^^^
! 
!   PrintGates  : outputs the gates read if in DEBUG mode
!   GetLibToken : tokenizer for the genlib file
!   IsHere      : formals check
!   ScanLibrary : parses the genlib files and builds the data structure.
!   WhatGate    : checks for a cell into the library struct.
! 
!  *=========================================================================*/
! 
! /* -=[ PrintGates ]=-                               *
!  * A kind debugger procedure ...                    *
   *                                                  *
!  * Input  :                                         *
!  *      cell = library file                         */
! void PrintGates(cell)
! struct LibCell *cell;
  {
!     struct Ports *ptr;
!     int    j;
!     
!     while(cell->next!=NULL){
! 	if (cell->clk[0]) {
! 	    (void)fprintf(stderr,"Latch name: %s, num pins : %d\n",cell->name,cell->npins);
! 	} else {
! 	    (void)fprintf(stderr,"Cell name: %s, num pins : %d\n",cell->name,cell->npins);
! 	}
! 	ptr=cell->formals;
! 	for(j=0; j<cell->npins; j++, ptr++){
! 	    (void)fprintf(stderr,"\tpin %d : %s\n",j,ptr->name);
! 	}
! 	if (cell->clk[0]) {
! 	    (void)fprintf(stderr,"\tclock : %s\n",cell->clk);
! 	}
! 	cell=cell->next;
!     }
! }
  
+ /* -=[ GetTypeOfCell ]=-                            *
+  * Scans the genlib data structure to find the      *
+  * type of the cell                                 *
+  *                                                  *
+  * Input  :                                         *
+  *      cell = library file                         *
+  *      name = name of cell to match                *
+  * Output :                                         *
+  *      type of cell                                */
+ char GetTypeOfCell(cell,name)
+ struct LibCell *cell;
+ char *name;
+ {
+     while(cell->next!=NULL){
+ 	if (KwrdCmp(cell->name,name)) {
+ 	    if (cell->clk[0]) {
+ 		return 'L';   /* Library celly, type = L(atch) */
+ 	    } else {
+ 		return 'G';   /* Library celly, type = G(ate)  */
+ 	    }
+ 	}
+ 	cell=cell->next;
+     }
+     return 'S';   /* type = S(ubcircuit) */
+ }
  
! /* -=[ GetLibToken ]=-                              *
!  * Tokenizer to scan the library file               *
!  *                                                  *
!  * Input  :                                         *
!  *      Lib = library file                          *
!  * Output :                                         *
!  *      tok = filled with the new token             */
! void GetLibToken(Lib,tok)
! FILE *Lib;
! char *tok;
! {
!     enum states { tZERO, tLONG, tEOF, tSTRING, tREM };
!     static enum states next;
!     static char init=0;
!     static char sentback;
!     static char TOKEN[MAXTOKENLEN];
!     static char str;
!     char   ready;
!     int    num;
!     char   *t;
!     char   c;
  
!     if (!init){
! 	sentback=0;
! 	init=1;
! 	next=tZERO;
! 	str=0;
!     }
  
!     t=&(TOKEN[0]);
!     num=0;
!     str=0;
  
!     do{
! 	if (sentback){
! 	    c=sentback;
! 	} else {
! 	    c=fgetc(Lib);
! 	}
! 	if (feof(Lib)) next=tEOF;
! 	ready=0;
! 	sentback='\0';
  
! 	switch (next) {
! 	  case tZERO:
! 	    if ((c==' ') || (c=='\r') || (c=='\t')){
! 		next=tZERO;
! 	    } else {
! 		if (c=='#') {
!                     next=tREM;
!                 } else {
! 		    if ( ((c>=0x27) && (c<=0x2b)) || (c=='=') || (c==';') || (c=='\n') || (c=='!')){
! 			*t=c; t++;
! 			next=tZERO;
! 			ready=1;
! 		    } else {
! 			if (c=='"') {
! 			    num=0;
! 			    next=tSTRING;
! 			} else
! 			    {
! 				num=0;
! 				next=tLONG;
! 				ready=0;
! 				sentback=c;
! 			    }
! 		    }
! 		}
! 	    }
! 	    break;
! 	  case tLONG:
! 	    if ((c==' ') || (c=='\r') || (c=='\t')){
! 		ready=1;
! 		next=tZERO;
! 	    } else {
! 		if ( ((c>=0x27) && (c<=0x2b)) || (c=='=') || (c==';') || (c=='\n') || (c=='!')){
! 		    next=tZERO;
! 		    ready=1;
! 		    sentback=c;
! 		} else {
! 		    if (c=='"') {
! 			ready=1;
! 			next=tSTRING;
! 		    } else {
!                         if (c=='#') {
!                             ready=1;
!                             next=tREM;
! 			} else {
! 			    *t=c;
! 			    t++; num++;
! 			    next=tLONG;
! 			    if ( (ready=(num>=MAXTOKENLEN-1)) )
! 			    (void)fprintf(stderr,"Sorry, exeeded max name len of %u",num+1);
! 			}
! 		    }
! 		}
! 		   
! 	    }
! 	    break;
! 	  case tSTRING:
! 	    if (!str) {
! 		*t='"'; t++; num++;
! 		str=1;
! #ifdef DEBUG
!                 (void)fprintf(stderr,"<%c>\n",c);
! #endif
! 	    }
! 	    *t=c; t++; num++;
! 	    if (c=='"') {   /* last dblquote */
! 		ready=1;
! 		next=tZERO;
! #ifdef DEBUG
! 		(void)fprintf(stderr,"STRING : %s\n",TOKEN);
! #endif
! 		break;
! 	    }
! 	    next=tSTRING;
! 	    if ( (ready=(num>=MAXTOKENLEN-1)) )
! 		(void)fprintf(stderr,"Sorry, exeeded max name len of %u",num+1);
! 	    break;
! 	  case tREM:
! 	    next=tREM;
! 	    if (c=='\n'){
! 		sentback=c;
! 		next=tZERO;
! 	    }
! 	    break;
! 	  case tEOF:
! 	    next=tEOF;
! 	    ready=1;
! 	    sentback=c;
! 	    *t=c;
! #ifdef DEBUG
! 	    (void)fprintf(stderr,"EOF\n");
! #endif
! 	    break;
! 	  default :
! 	      next=tZERO;
! 	}
!     } while(!ready);
!     *t='\0';
!     (void)strcpy(tok,&(TOKEN[0]));
! }
  
+ /* -=[ IsHere ]=-                                   * 
+  * Check is a name has been already used in the     *
+  * expression. Here we look only at names, 'unused' * 
+  * flag here is not useful.                         *
+  *                                                  *
+  * Input  :                                         *
+  *     ptr  = pointer to list of formals            *
+  *     name = name to check                         *
+  * Output :                                         *
+  *     pointer = if 'name' is used                  *
+  *     NULL    = if used                            */
+ struct BITstruct *IsHere(name,ptr)
+ char *name;
+ struct BITstruct *ptr;
+ {
+     struct BITstruct *BITptr;
  
!     BITptr=ptr;
!     while(BITptr->next!=NULL){
!         BITptr=BITptr->next;
!         if (KwrdCmp(name,BITptr->name)) return BITptr;
!     }
!     return (struct BITstruct *)NULL;
! }
  
! struct LibCell *NewLibCell(name,ports,latch)
! char *name;
! struct BITstruct *ports;
! int latch;
! {
!     struct LibCell      *tmp;
!     struct BITstruct *bptr;
!     struct Ports     *pptr;
!     int    j;
!     int    num;
!     
!     if ( (tmp=(struct LibCell *)calloc(1,sizeof(struct LibCell)))== NULL ) {
! 	Error("Allocation Error or not enought memory !");
!     }
! 
!     for(bptr=ports, num=1; bptr->next!=NULL; num++, bptr=bptr->next);
!     if (latch ) num--;
! 	
!     if ( (tmp->formals=(struct Ports *)calloc(1,num*sizeof(struct Ports)))==NULL){
! 	    Error("Allocation Error or not enought memory !");
! 	}
! 
!     (void)strcpy(tmp->name,name);
!     tmp->next=NULL;
!     tmp->npins=num; num--;
!     for(bptr=ports->next, pptr=tmp->formals, j=0; (j<num) && (bptr!=NULL)
! 	                                  ; pptr++, j++, bptr=bptr->next ){
! 	if (j>num) Error("(NewLibCell) error ...");
! #ifdef DEBUG
! 	(void)fprintf(stderr,"(NewLibCell):adding %s\n",bptr->name);
! #endif
! 	(void)strcpy(pptr->name,bptr->name);
!     }
!     (void)strcpy(pptr->name,ports->name); /* output is the last one */
!     if (latch) {
! 	(void)strcpy(tmp->clk,bptr->name);
! #ifdef DEBUG
! 	(void)fprintf(stderr,"(NewLibCell):clock %s\n",bptr->name);
! #endif
!     } else {
! 	tmp->clk[0]='\0';
!     }
!     ReleaseBit(ports);
!     return tmp;
  }
  
  
! /* -=[ ScanLibrary ]=-                              *
!  * Scans the library to get the namesof the cells   *
!  * the output pins and the clock signals of latches *
   *                                                  *
   * Input :                                          *
!  *     LibName = the name of library file           */
! struct LibCell *ScanLibrary(LibName)
! char *LibName;
  {
!     enum states { sZERO, sPIN, sCLOCK, sADDCELL } next;
!     FILE *Lib;
!     struct LibCell      *cell;
!     struct LibCell      first;
!     struct BITstruct *tmpBIT;
!     struct BITstruct firstBIT;
!     char LocalToken[MAXTOKENLEN];
!     char name[MAXNAMELEN];
!     int  latch;
!     char *s;
!     
  
!     if ((Lib=fopen(LibName,"rt"))==NULL)
! 	Error("Couldn't open library file");
  
! 
! /*    first.next=NewLibCell("_dummy_",(struct BITstruct *)NULL,LIBRARY); */
!     firstBIT.name[0]='\0'; firstBIT.next=NULL;
!     cell=&first;
!     s=&(LocalToken[0]);
!     latch=0; next=sZERO;
!     (void)fseek(Lib,0L,SEEK_SET);
!     tmpBIT=&firstBIT;
!     do {
! 	GetLibToken(Lib,s);
! 	switch (next) {
! 	  case sZERO:
! 	    next=sZERO;
! 	    if (KwrdCmp(s,"GATE")) {
! 		latch=0;
! 		GetLibToken(Lib,s);
! 		(void)strcpy(name,s);
! 		GetLibToken(Lib,s);   /* area */
! 		next=sPIN;
! #ifdef DEBUG
! 		(void)fprintf(stderr,"Gate name: %s\n",name);
! #endif
  	    } else {
! 		if (KwrdCmp(s,"LATCH")) {
! 		    latch=1;
! 		    GetLibToken(Lib,s);
! 		    (void)strcpy(name,s);
! 		    GetLibToken(Lib,s);   /* area */
! 		    next=sPIN;
! #ifdef DEBUG
! 		    (void)fprintf(stderr,"Latch name: %s\n",name);
! #endif
! 		}
! 	    }
! 	    break;
! 	  case sPIN:
! 	    if ( !( ((*s>=0x27) && (*s<=0x2b)) || (*s=='=') || (*s=='!')|| (*s==';')) ){
! /*
! 		(void)strncpy(tmp,s,5);
! 		if (KwrdCmp(tmp,"CONST") && !isalpha(*(s+6)))
! */
! 		    /* if the expression has a constant value we must */
! 		    /* skip it, because there are no inputs           */
! /*
! 		    break;
! */
! 		/* it's an operand so get its name */
! #ifdef DEBUG
! 		(void)fprintf(stderr,"\tpin read : %s\n",s);
! #endif
! 		if (IsHere(s,&firstBIT)==NULL) {
! #ifdef DEBUG
! 		    (void)fprintf(stderr,"\tunknown pin : %s --> added!\n",s);
! #endif
! 		    AddBIT(&tmpBIT,s);
! 		}
! 	    }
! 	    if (*s==';') {
! 		if (latch) {
! 		    next=sCLOCK;
! 		} else {
! 		    next=sADDCELL;
! 		}
! 	    } else {
! 		next=sPIN;
! 	    }
! 	    break;
! 	  case sCLOCK:
! 	    if (KwrdCmp(s,"CONTROL")){
! 		GetLibToken(Lib,s);
! #ifdef DEBUG
! 		(void)fprintf(stderr,"\tcontrol pin : %s\n",s);
! #endif
! 		AddBIT(&tmpBIT,s);
! 		next=sADDCELL;
! 	    } else {
! 		next=sCLOCK;
! 	    }
! 	    break;
! 	  case sADDCELL:
! #ifdef DEBUG
! 	      (void)fprintf(stderr,"\tadding cell to library\n");
! #endif
! 	    cell->next=NewLibCell(name,firstBIT.next,latch);
! 	    tmpBIT=&firstBIT; firstBIT.next=NULL;
! 	    cell=cell->next;
! 	    next=sZERO;
! 	    break;
! 	}
!     } while (!feof(Lib));
! 
!     if ((first.next)->next==NULL) {
! 	(void)sprintf("Library file %s does *NOT* contains gates !",LibName);
! 	Error("could not continue with an empy library");
!     }
! #ifdef DEBUG
!     (void)fprintf(stderr,"end of lib\n");
!     PrintGates(first.next);
! #endif
!     return (struct LibCell *)first.next;
  }
  
! 
! /* -=[ WhatGate ]=-                                 *
!  * Returns a pointer to an element of the list      *
!  * of gates that matches up the name given, if      *
!  * ther isn't a match a null pointer is returned    *
!  *                                                  *
!  * Input :                                          *
!  *     name = name to match                         *
!  *     LIBRARY = genlib data struct                 *
!  * Ouput :                                          *
!  *     (void *) a pointer                           */
! struct LibCell *WhatLibGate(name,LIBRARY)
! char *name;
! struct LibCell *LIBRARY;
  {
!     struct LibCell  *ptr;
  
!     for(ptr=LIBRARY; ptr!=NULL ; ptr=ptr->next)
! 	if ( KwrdCmp(ptr->name,name) ) return ptr;
  
+     return (struct LibCell *)NULL;
+ }
+ 
+ /*=========================================================================*
+ 
+ 
+ 
+  *=========================================================================*/
+ 
+ struct Cell *NewCell(name,Bports,Fports,Genlib)
+ char *name;
+ struct SIGstruct *Bports;
+ struct BITstruct *Fports;
+ struct LibCell *Genlib;
+ {
+     struct Cell      *tmp;
+     struct BITstruct *Fptr;
+     struct Ports     *Pptr;
+     struct Ports     *Lpptr;
+     struct LibCell   *Lptr;
+     int    j;
+     int    num;
+     char   t;
+  
+     if ( (tmp=(struct Cell *)calloc(1,sizeof(struct Cell)))== NULL ) {
+ 	Error("Allocation Error or not enought memory !");
+     }
+ 
+     if (Bports!=NULL){
+ 	j=1;
+ 	Fptr=Fports;
+ 	while(Fptr->next!=NULL){
+ 	    j++; Fptr=Fptr->next;
+ 	}
+ 	num=j;
+ 	t=GetTypeOfCell(Genlib,name);
+ 	if (t=='L') j++;
+ 	
+ 	if ( (tmp->formals=(struct Ports *)calloc(1,j*sizeof(struct Ports)))==NULL){
+ 	    Error("Allocation Error or not enought memory !");
+ 	}
+ 	(void)strcpy(tmp->name,name);
+ 	tmp->npins=j;
+ 	tmp->next=NULL;
+ 	tmp->type=t;
+ 
+ 	if (t=='S') {
+ 	    /*                                           *
+ 	     * Is a subcircuit, no ordering is necessary *
+ 	     *                                           */
+ 	    Fptr=Fports;
+ 	    Pptr=tmp->formals;
+ 	    j=0;
+ 	    while(Fptr!=NULL){
+ 		if (j>num) Error("(NewCell) error ...");
+ #ifdef DEBUG
+ 		(void)fprintf(stderr,"(NewCell): adding %s\n",Fptr->name);
+ #endif
+ 		(void)strcpy(Pptr->name,Fptr->name);
+ 		Fptr=Fptr->next;
+ 		Pptr++; j++;
+ 	    }
+ 	    ReleaseBit(Fports->next);
+ 	    tmp->io=Bports->next;
+ 	    Bports->next=NULL;
+ 	} else {
+ 	    /*                                            *
+ 	     * Is a library cell, let's order the signals *
+ 	     * to simplify the final output               * 
+ 	     *                                            */	     
+ 	    Lptr=WhatLibGate(name,Genlib);
+ 	    Pptr=tmp->formals;
+ 	    if (t=='L') num--;
+ 	    for(j=1, Lpptr=Lptr->formals; j<num; j++, Lpptr++, Pptr++) {
+ 		Fptr=Fports->next;
+ #ifdef DEBUG
+ 		(void)fprintf(stderr,"\npin %s \n",Lpptr->name);
+ #endif
+ 		while(Fptr!=NULL){
+ #ifdef DEBUG
+ 		    (void)fprintf(stderr,"is %s ?\n",Fptr->name);
+ #endif
+ 		    if (KwrdCmp(Fptr->name,Lpptr->name)) {
+ 			(void)strcpy(Pptr->name,Fptr->name);
+ 			break;
+ 		    }
+ 		    Fptr=Fptr->next;
+ 		}
+ 		if (Fptr==NULL) (void) Error("Mismatch between COMPONENT declaration and library one");
+ 	    }
+ 	    if (t=='L') {
+ 		Fptr=Fports->next;
+ 		while(Fptr!=NULL){
+ 		    if (KwrdCmp(Fptr->name,Lptr->clk)) {
+ 			(void)strcpy(Pptr->name,Fptr->name);
+ 			break;
+ 		    }
+ 		    Fptr=Fptr->next;
+ 		}
+ 		if (Fptr==NULL) (void) Error("Mismatch between COMPONENT declaration and libray one");
+ 	    }
+ 	    ReleaseBit(Fports->next);
+ 	    tmp->io=Bports->next;
+ 	    Bports->next=NULL;
+ 	    
+ 	}
+ 
+     } else {
+ 	tmp->formals=NULL;
+     }
+     return tmp;
+ }
+ 
+ 
+ /* -=[ WhatGate ]=-                                 *
+  * Returns a pointer to an element of the list      *
+  * of gates that matches up the name given, if      *
+  * ther isn't a match a null pointer is returned    *
+  *                                                  *
+  * Input :                                          *
+  *     name = name to match                         *
+  *     LIBRARY = components data struct             *
+  * Ouput :                                          *
+  *     (void *) a pointer                           */
+ struct Cell *WhatGate(name,LIBRARY)
+ char *name;
+ struct Cell *LIBRARY;
+ {
+     struct Cell  *ptr;
+ 
+     for(ptr=LIBRARY; ptr!=NULL ; ptr=ptr->next)
+ 	if ( KwrdCmp(ptr->name,name) ) return ptr;
+ 
+     return (struct Cell *)NULL;
+ }
+ 
+ 
  /* -=[ GetPort ]=-                                 *
   * Gets the port definition of an ENTITY or of a   *
   * COMPONENT.                                      *
!  *                                                 */
! struct Cell *GetPort(Cname)
! char *Cname;
  {
!     enum states { sFORMAL, sCONN, sANOTHER, sDIR, sTYPE, sVECTOR, sWAIT } next;
!     struct SIGstruct BITstart;
!     struct BITstruct FORMstart;
!     struct SIGstruct *BITptr;
!     struct BITstruct *FORMptr;
!     struct BITstruct *TMPptr;
!     struct BITstruct TMPstart;
      char *w;
      char LocalToken[MAXTOKENLEN];
!     char tmp[MAXNAMELEN];
!     char dir;
!     int  Cont;
!     int  Token;
!     int  start;
!     int  end;
!     int  j;
!     int  num;
!     
  
+     w=&(LocalToken[0]);
  
      GetNextToken(w);
      if ( *w!='(' ) Warning("expected '('");
  
!     BITptr=&BITstart;
!     FORMptr=&FORMstart;
!     TMPstart.next=NULL;
! 
!     dir = '\0';
!     Token=1; start=0; end=0;
!     next=sFORMAL;
!     Cont=1; num=0;
      do{
  	/* name of the port */
! 	if (Token) GetNextToken(w);
! 	else Token=1;
! 	switch (next) {
! 	  case sFORMAL:
! #ifdef DEBUG
! 	      (void)fprintf(stderr,"\n\n** getting formal : %s",w);
! #endif
! 	    (void)strcpy(TMPstart.name,w);
! 	    TMPptr=&TMPstart;
! 	    next=sCONN;
! 	    break;
! 	  case sCONN:
! 	    next=sDIR;
! 	    if (*w!=':') {
! 		if (*w==',') {
! 		    next=sANOTHER;
! 		} else {
! 		    Warning("Expected ':' or ',' ",line);
! 		    Token=0;
! 		}
! 	    }
! 	    break;
! 	  case sANOTHER:
! #ifdef DEBUG
! 	      (void)fprintf(stderr,"\n*** another input : %s",w); 
! #endif
! 	    if (TMPptr->next==NULL) {
! 		AddBIT(&TMPptr,w,1);
! 	    } else {
! 		TMPptr=TMPptr->next;
! 		(void)strcpy(TMPptr->name,w);
! 	    }
! 	    num++;
! 	    next=sCONN;
! 	    break;
! 	  case sDIR:
! #ifdef DEBUG
! 	      (void)fprintf(stderr,"\n\tdirection = %s",w);
! #endif
! 	    if (KwrdCmp(w,"IN")){
! 		dir='i';
! 	    } else {
! 		if (KwrdCmp(w,"OUT")) {
! 		    dir='o';
! 		} else {
! 		    if (KwrdCmp(w,"INOUT")){
! 			dir='u';
! 		    } else {
! 			if (KwrdCmp(w,"LINKAGE")){
! 			    dir=LINKAGE;
! 			} else {
! 			    (void)fprintf(stderr,"* Error * Line %u : unknown direction of a port\n",line);
! 			    Error("Could not continue");
! 			}
! 		    }
! 		}
! 	    }
! 	    next=sTYPE;
! 	    break;
! 	  case sTYPE:
! 	    if (KwrdCmp(w,"BIT")) {
! 		next=sWAIT;
! 		start=end;
! 	    } else {
! 		if (KwrdCmp(w,"BIT_VECTOR")) {
! #ifdef DEBUG
! 		    (void)fprintf(stderr,"\n\tvector, ");
! #endif
! 		    next=sVECTOR;
! 		}
! 	    }
! 	    break;
! 	  case sVECTOR:
! 	    if (*w!='(') {
! 		Warning("Expected '('");
! 	    } else {
! 		GetNextToken(w);
! 	    }
! 	    start=DecNumber(w);
  	    GetNextToken(w);
! 	    if (!KwrdCmp(w,"TO") && !KwrdCmp(w,"DOWNTO")){
! 		Warning("Expected keword TO or DOWNTO");
! 	    } else {
! 		GetNextToken(w);
! 	    }
! 	    end=DecNumber(w);
  	    GetNextToken(w);
+ 	    if (*w!=')') {
+ 		Warning("Expected ')'");
+ 		Token=1;
+ 	    }
+ 	    next=sWAIT;
+ #ifdef DEBUG
+ 	      (void)fprintf(stderr," from %d to %d",start,end);
+ #endif
+ 	    break;
+ 	  case sWAIT:
+ 	    TMPptr=&TMPstart;
+ 	    /* if (num>0) num--; */
+ #ifdef DEBUG
+ 	      (void)fprintf(stderr,"\nPower?");
+ #endif
+ 	    if (!(KwrdCmp(TMPptr->name,VDD) || KwrdCmp(TMPptr->name,VSS))){
+ #ifdef DEBUG
+ 		(void)fprintf(stderr," no\n");
+ #endif
  
! 	    while(num>=0){
! #ifdef DEBUG
! 		(void)fprintf(stderr,"\n\n%d)working on %s",num,TMPptr->name);
! #endif
! 		if (start==end) {
! #ifdef DEBUG
! 		    (void)fprintf(stderr,"\nadded bit & formal of name : %s",TMPptr->name);
! #endif
! 		    AddSIG(&BITptr,TMPptr->name,dir,0,0);
! 		    AddBIT(&FORMptr,TMPptr->name,dir);
! 		} else {
! 		    if (start>end){
! 			for(j=start; j>=end; j--) {
! 			    (void)sprintf(tmp,"%s[%d]",TMPptr->name,j);
! #ifdef DEBUG
! 			    (void)fprintf(stderr,"\nadded formal of name : %s",tmp);
! #endif
! 			    AddBIT(&FORMptr,tmp,dir);
! 			}
! #ifdef DEBUG
! 			(void)fprintf(stderr,"\nadded vector of name : %s[%d..%d]",TMPptr->name,start,end);
! #endif
! 		    } else {
! 			for(j=start; j<=end; j++) {
! 			    (void)sprintf(tmp,"%s[%d]",TMPptr->name,j);
! #ifdef DEBUG
! 			    (void)fprintf(stderr,"\nadded formal of name : %s",tmp);
! #endif
! 			    AddBIT(&FORMptr,tmp,dir);
! 			}
! #ifdef DEBUG
! 			(void)fprintf(stderr,"\nadded vector of name : %s[%d..%d]",TMPptr->name,start,end);
! #endif
! 		    }
! 		    AddSIG(&BITptr,TMPptr->name,dir,start,end);
! 		}
! 		TMPptr=TMPptr->next;
! 		num--;
! 	    }
  
! 	}
! 	    num=0;
! 	    if (*w==';') {
! 		    next=sFORMAL;
  		} else {
! 		    if (*w!=')') {
! 		    VstError("Missing ')' or ';'","END");
! 		} else {
! 		    GetNextToken(w);  /* ; */
! 		    if (*w != ';') {
! 			Warning("Missing ';'");
  		    } else {
! 			GetNextToken(w);  /* end */
! 		    }
! 		    if (!KwrdCmp(w,"END")){
! 			VstError("Missing END keyword","END");
! 		    }
! 		}
! 		Cont=0;
! 	    }
! 	    break;
! 	}
  
!     } while (Cont);
!     ReleaseBit(TMPstart.next);
!     return NewCell(Cname,&BITstart,&FORMstart,LIBRARY);
! }
  
  
  /* -=[ GetEntity ]=-                                *
   * parses the entity statement                      */
! void GetEntity(Entity)
! struct Cell **Entity;
  {
      char *w;
      char LocalToken[MAXTOKENLEN];
***************
*** 1172,1183 ****
      char name[MAXTOKENLEN];
      int  num;
  
!     w= &(LocalToken[0]);
  
      /* name of the entity = name of the model */
      GetNextToken(w);
!     (void) strcpy(name,w);
!     (void) fprintf(Out,".model %s\n",w);
      GetNextToken(w);
      if (!KwrdCmp(w,"IS")) Warning("expected syntax: ENTITY <name> IS");
  
--- 1503,1513 ----
      char name[MAXTOKENLEN];
      int  num;
  
!     w=&(LocalToken[0]);
  
      /* name of the entity = name of the model */
      GetNextToken(w);
!     (void)strcpy(name,w);
      GetNextToken(w);
      if (!KwrdCmp(w,"IS")) Warning("expected syntax: ENTITY <name> IS");
  
***************
*** 1192,1238 ****
  	    if (*w=='(') num++;
  	    else {
  		if (*w==')') num--;
! 	    };
  	} while (num!=0);
  	GetNextToken(w);
  	if (*w!=';') Warning("expected ';'");
  	GetNextToken(w);
!     };
  
      /* PORT CLAUSE */
      if (KwrdCmp(w,"PORT")) {
! 	GetPort(1);
      } else {
  	Warning("no inputs or outputs in this entity ?!");
!     };
  
-     /* END CLAUSE */
      GetNextToken(w);
-     if (!KwrdCmp(w,"END")) {
- 	VstError("Keyword missing !","END");
- 	/* something went wrong.. we will re-synchronize with  *
- 	 * the source text when we will reach the END keyword  */
-     };
- 
-     GetNextToken(w);
      if (!KwrdCmp(w,name))
  	Warning("<name> after END differs from <name> after ENTITY");
  
      GetNextToken(w);
      if (*w!=';') Warning("expected ';'");
  
- };
- 
  /* -=[ GetComponent ]=-                             *
   * Parses the component statement                   */
! void GetComponent()
  {
      char *w;
      char LocalToken[MAXTOKENLEN];
  
!     w= &(LocalToken[0]);
      /* component name */
      GetNextToken(w);
  
      /* A small checks may be done here ... next time */
  
--- 1522,1565 ----
  	    if (*w=='(') num++;
  	    else {
  		if (*w==')') num--;
! 	    }
  	} while (num!=0);
  	GetNextToken(w);
  	if (*w!=';') Warning("expected ';'");
  	GetNextToken(w);
!     }
  
      /* PORT CLAUSE */
      if (KwrdCmp(w,"PORT")) {
! 	(*Entity)=GetPort(name);
      } else {
  	Warning("no inputs or outputs in this entity ?!");
!     }
  
      GetNextToken(w);
      if (!KwrdCmp(w,name))
  	Warning("<name> after END differs from <name> after ENTITY");
  
      GetNextToken(w);
      if (*w!=';') Warning("expected ';'");
+ }
  
  /* -=[ GetComponent ]=-                             *
   * Parses the component statement                   */
! void GetComponent(cell)
! struct Cell **cell;
  {
      char *w;
      char LocalToken[MAXTOKENLEN];
+     char name[MAXNAMELEN];
  
!     w=&(LocalToken[0]);
      /* component name */
      GetNextToken(w);
+     (void)strcpy(name,w);
+ #ifdef DEBUG
+     (void)fprintf(stderr,"\nParsing component %s\n",name);
+ #endif
  
      /* A small checks may be done here ... next time */
  
***************
*** 1239,1285 ****
      /* PORT CLAUSE */
      GetNextToken(w);
      if (KwrdCmp(w,"PORT")) {
! 	GetPort(0);
      } else {
  	Warning("no inputs or outputs in this component ?!");
!     };
  
  
      /* END CLAUSE */
      GetNextToken(w);
-     if (!KwrdCmp(w,"END")) {
- 	Warning(" END keyword missing !");
-     };
- 
-     GetNextToken(w);
      if (!KwrdCmp(w,"COMPONENT")) {
  	Warning("COMPONENT keyword missing !");
!     };
  
      GetNextToken(w);
      if (*w!=';') Warning("expected ';'");
  
! };
  
  /* -=[ GetSignal ]=-                                 *
   * Skips the signal definitions                      */
! void GetSignal()
  {
      char *w;
      char LocalToken[MAXTOKENLEN];
  
-     /* We're not interested in signals definition, so we will skip *
-      * all the entry --> just go to the next ';'                   */
  
!     w= &(LocalToken[0]);
!     do{
  	GetNextToken(w);
! 	if (feof(In))
! 	    Error("Unespected Eof");
!     } while (*w!=';');
  
  }
  
  /* -=[ GetName ]=-                                   *
   * Gets a name of an actual terminal, that can be    *
   * a single token or 3 tokens long (if it is an      *
--- 1566,1776 ----
      /* PORT CLAUSE */
      GetNextToken(w);
      if (KwrdCmp(w,"PORT")) {
! 	(*cell)->next=GetPort(name);
! 	(*cell)=(*cell)->next;
      } else {
  	Warning("no inputs or outputs in this component ?!");
!     }
  
  
      /* END CLAUSE */
      GetNextToken(w);
      if (!KwrdCmp(w,"COMPONENT")) {
  	Warning("COMPONENT keyword missing !");
!     }
  
      GetNextToken(w);
      if (*w!=';') Warning("expected ';'");
  
! }
  
  /* -=[ GetSignal ]=-                                 *
   * Skips the signal definitions                      */
! void GetSignal(Internals)
! struct SIGstruct **Internals;
  {
+     struct SIGstruct *SIGptr;
+     struct SIGstruct *SIGstart;
      char *w;
      char LocalToken[MAXTOKENLEN];
+     char name[MAXNAMELEN];
+     char dir;
+     int vect;
+     int  start;
+     int  end;
  
  
!     SIGstart=(struct SIGstruct *)calloc(1,sizeof(struct SIGstruct));
!     if (SIGstart==NULL) {
! 	Error("Allocation Error or not enought memory !"); 
!     }
!     SIGptr=SIGstart;
! 
!     w=&(LocalToken[0]);
! 
!     dir = '\0';
! 
!     do {
  	GetNextToken(w);
! #ifdef DEBUG
! 	(void)fprintf(stderr,"\n\n** getting signal %s",w);
! #endif
! 	AddSIG(&SIGptr,w,'*',999,999);
! 	GetNextToken(w);
!     } while (*w==',');
  
+     if (*w!=':') {
+ 	Warning("Expected ':'");
+     } else {
+ 	GetNextToken(w);
+     }
+ 	
+     start=0; end=0;
+     vect=0;
+     if (*(w+3)=='_') {
+ 	*(w+3)='\0';
+ 	vect=1;
+     }
+     if (KwrdCmp(w,"BIT")) {
+ 	dir='b';
+     } else {
+ 	if (KwrdCmp(w,"MUX")) {
+ 	    dir='m';
+ 	} else {
+ 	    if (KwrdCmp(w,"WOR")) {
+ 		dir='w';
+ 	    }
+ 	}
+     }
+     if (vect && !KwrdCmp(w+4,"VECTOR")) {
+ 	(void)fprintf(stderr," Unknown signal type : %s\n",w);
+ 	Error("could not continue.");
+     }
+ 
+     if (vect) {
+ 	GetNextToken(w);
+ 	if (*w!='(') {
+ 	    Warning("Expected '('");
+ 	} else {
+ 	    GetNextToken(w);
+ 	}
+ 	start=DecNumber(w);
+ 	GetNextToken(w);
+ 	if (!KwrdCmp(w,"TO") && !KwrdCmp(w,"DOWNTO")){
+ 	    Warning("Expected keword TO or DOWNTO");
+ 	} else {
+ 	    GetNextToken(w);
+ 	}
+ 	
+ 	end=DecNumber(w);
+ 	GetNextToken(w);
+ 	if (*w!=')') {
+ 	    Warning("Expected ')'");
+ 	}
+ #ifdef DEBUG
+ 	(void)fprintf(stderr," from %d to %d",start,end);
+ #endif
+     }
+     
+     GetNextToken(w);
+     if (dir!='b') {
+ 	if (!KwrdCmp(w,"BUS")) {
+ 	    Warning(" Keyword 'BUS' expected");
+ 	} else {
+ 	    GetNextToken(w);
+ 	}
+     }
+ 
+     SIGptr=SIGstart;
+     while (SIGptr->next!=NULL) {
+ 	SIGptr=SIGptr->next;
+ 	if (vect) {
+ #ifdef DEBUG
+ 	    (void)fprintf(stderr,"\nadded vector of name : %s[%d..%d]",name,start,end);
+ #endif
+ 	    AddSIG(Internals,SIGptr->name,dir,start,end);
+ 	} else {
+ #ifdef DEBUG
+ 	    (void)fprintf(stderr,"\nadded bit of name : %s",name);
+ #endif
+ 	    AddSIG(Internals,SIGptr->name,dir,0,0);
+ 	}
+     }
+     ReleaseSIG(SIGstart);
+     
+     if (*w!=';') {
+ 	Warning("expected ';'");
+     }
+ 
  }
  
+ 
+ void FillTerm(TERM,Entity,which,WhatCell)
+ struct TERMstruct   *TERM;
+ struct ENTITYstruct *Entity;
+ int    which;
+ struct Cell      *WhatCell;
+ {
+     struct Cell      *cell;
+     struct SIGstruct *Sptr;
+ 
+ #ifdef DEBUG
+     (void)fprintf(stderr,"filling dimension of %s\n",TERM->name);
+ #endif
+     if (which) {
+ #ifdef DEBUG
+ 	(void)fprintf(stderr,"searchin into component %s\n",WhatCell->name);
+ #endif
+ 	cell=Entity->Components;
+ 	while(cell!=NULL){
+ 	    if (!strcmp(cell->name,WhatCell->name)) {
+ 		Sptr=cell->io;
+ 		while (Sptr!=NULL){
+ 		    if (KwrdCmp(TERM->name,Sptr->name)){
+ 			TERM->start=Sptr->start;
+ 			TERM->end=Sptr->end;
+ 			return;
+ 		    }
+ 		    Sptr=Sptr->next;
+ 		}
+ 	    }
+ 	    cell=cell->next;
+ 	}
+     } else {
+ 	Sptr=(Entity->EntityPort)->io;
+ 	while (Sptr!=NULL){
+ #ifdef DEBUG
+ 	    (void)fprintf(stderr,"searchin into io\n");
+ #endif
+ 	    if (KwrdCmp(TERM->name,Sptr->name)){
+ 		TERM->start=Sptr->start;
+ 		TERM->end=Sptr->end;
+ 		return;
+ 	    }
+ 	    Sptr=Sptr->next;
+ 	}
+ 	Sptr=Entity->Internals;
+ 	while (Sptr!=NULL){
+ #ifdef DEBUG
+ 	    (void)fprintf(stderr,"searchin into internals\n");
+ #endif
+ 	    if (KwrdCmp(TERM->name,Sptr->name)){
+ 		TERM->start=Sptr->start;
+ 		TERM->end=Sptr->end;
+ 		return;
+ 	    }
+ 	    Sptr=Sptr->next;
+ 	}
+ 	if (KwrdCmp(TERM->name,VSS) || KwrdCmp(TERM->name,VDD)) {
+ 	    TERM->start=0; TERM->end=0;
+ 	    return;
+ 	}
+ 	(void)fprintf(stderr,"Signal name %s not declared",TERM->name);
+ 	Error("Could not continue");
+     }
+ }
+ 
+ 
  /* -=[ GetName ]=-                                   *
   * Gets a name of an actual terminal, that can be    *
   * a single token or 3 tokens long (if it is an      *
***************
*** 1287,1474 ****
   *                                                   *
   * Output :                                          *
   *     name = the name read                          */
! void GetName(name)
! char *name;
  {
      char *w;
      char LocalToken[MAXTOKENLEN];
  
!     w= &(LocalToken[0]);
      GetNextToken(w);
!     (void) strcpy(name,w);
!     GetNextToken(w);
      if (*w!='(') {
  	SendTokenBack=1;
  	/* Don't lose this token */
  	return;
!     };
      GetNextToken(w);
!     (void) sprintf(name,"%s(%u)",name,DecNumber(w));
      GetNextToken(w);
!     if (*w!=')') Warning("expected ')'");
! };
  
- /* -=[ FreeConns ]=-                               *
-  * Releases the memory used for parsing the        *
-  * connections .                                   *
-  *                                                 *
-  * Input :                                         *
-  *     first = first element of the list, this     *
-  *             should *NOT* be released because    *
-  *             it is declared statically           */
- void FreeConns(first)
- struct connections *first;
- {
-     struct connections *tmp;
-     struct connections *ptr;
  
!     ptr=first->next;
!     if (ptr==NULL) return;
!     for (; ptr!=NULL; ) {
! 	tmp=ptr->next;
! 	free(ptr);
! 	ptr=tmp;
!     };
! };
! 
! /* -=[ ClearFormals ]=-                            *
!  * sets the unused flag to '1', this is performed  *
!  * each time the  cell is selected                 *
!  *                                                 *
!  * Input  :                                        *
!  *     cell = pointer to the cell structure        */
! void ClearFormals(cell)
! struct Cell *cell;
! { 
!     struct PortName *ptr;
! 
!     for(ptr=cell->inputs; ptr!=NULL; ptr=ptr->next){
! 	ptr->notused=1; 
!     };
!     
!     (cell->output)->notused=1;
!     if (cell->clock!=NULL) (cell->clock)->notused=1;
! 
! };
! 
! /* -=[ CheckFormals ]=-                            *
!  * Checks if a terminal has been used and then     *
!  * replaces its name with the une used in the cell *
!  * definition.                                     *
!  *                                                 *
!  * Input  :                                        *
!  *     cell = the cell (...)                       *
!  *     name = name of formal to check              */
! int CheckFormal(cell,name)
! struct Cell *cell;
! char   *name;
  {
!     struct PortName *ptr;
      
!     for(ptr=cell->inputs; ptr!=NULL; ptr=ptr->next){
! 	if (ptr->notused) {
! 	    if (KwrdCmp(ptr->name,name)){
! 		ptr->notused=0;
! 	        (void) strcpy(name,ptr->name);
! 		return 1;
! 	    };
! 	};
!     };
!     
!     ptr=cell->output;
!     if (ptr->notused) {
! 	if (KwrdCmp(ptr->name,name)){
! 	    ptr->notused=0;
! 	    (void) strcpy(name,ptr->name);
! 	    return 1;
! 	};
!     };
!     
!     ptr=cell->clock;
!     if ((ptr!=NULL) && (ptr->notused)) {
! 	if (KwrdCmp(ptr->name,name)){
! 	    ptr->notused=0;
! 	    (void) strcpy(name,ptr->name);
! 	    return 1;
! 	};
!     };
! 
!     return 0;
! };
! 
! 
! /* -=[ AllUsed]=-                                   *
!  * Checks if all the formals are connected          *
!  *                                                  *
!  * Input  :                                         *
!  *     cell = the cell to check;                    */
! int AllUsed(cell)
! struct Cell *cell;
! {
!     struct PortName *ptr;
!     
!     for(ptr=cell->inputs; ptr!=NULL; ptr=ptr->next){
! 	if (ptr->notused) return 0;
!     };
!     
!     if ((cell->output)->notused) return 0;
!      
!     if ((cell->clock!=NULL) && ((cell->clock)->notused)) return 0;
! 
!     return 1;
! };
! 
! 
  /* -=[ GetInstance ]=-                              *
   * parses the netlist                               */
! void GetInstance()
  {
!     struct connections first;
!     struct connections *ptr;
!     struct Cell        *ThisCell;
      char   *w;
      char   LocalToken[MAXTOKENLEN];
!     int   alim;
!     int   gate;
!     int   clk;
!     int   output;
!     char   tmp[MAXTOKENLEN];
!     char   clock[MAXTOKENLEN];
!     int   err;
  
!     
!     w= &(LocalToken[0]);
!     err=0;
!     output=0;
      GetNextToken(w);
!     if (*w!=':') Warning("Missing ':'");
  
!     /* name of the gate to use now */
!     GetNextToken(w);
!     gate=1;
!     if ((ThisCell=WhatGate(w))==NULL) {
! 	(void) sprintf(tmp,"Line %u : cell %s is *NOT* in the library",line,w);
! 	Error(tmp);
! 	/* This is the end ...                      *
! 	 * Is a gate or a latch ? we couldn't know  *
! 	 * so it's better to give up and wait for   *
! 	 * better times ..                          */
!     };
!     gate = (ThisCell->clock)==NULL;
!     ClearFormals(ThisCell);
  
!     /* We must use the names as they were written on the library file */
!     if (gate) {
! 	(void) fprintf(Out,".gate %s ",ThisCell->name);
!     } else {
! 	(void) fprintf(Out,".mlatch %s ",ThisCell->name);
!     };
  
      GetNextToken(w);
      if (!KwrdCmp(w,"PORT")) {
! 	VstError("PORT keyword missing","PORT");
! 	err=1;
!     };
  
      GetNextToken(w);
      if (!KwrdCmp(w,"MAP"))
--- 1778,1921 ----
   *                                                   *
   * Output :                                          *
   *     name = the name read                          */
! void GetName(TERM,Entity,which,WhatCell)
! struct TERMstruct   *TERM;
! struct ENTITYstruct *Entity;
! int   which;
! struct Cell      *WhatCell;
  {
      char *w;
      char LocalToken[MAXTOKENLEN];
  
!     TERM->start=-1; TERM->end=-1;
!     w=&(LocalToken[0]);
!     do {
! 	GetNextToken(w);
! #ifdef DEBUG
! 	(void)fprintf(stderr,"Parsing %s\n",w);
! #endif
!     } while ((*w==',') || (*w=='&'));
!     (void)strcpy(TERM->name,w);
      GetNextToken(w);
! #ifdef DEBUG
!     (void)fprintf(stderr,"then  %s\n",w);
! #endif
      if (*w!='(') {
+ 	FillTerm(TERM,Entity,which,WhatCell);
+ 	if ((TERM->start==TERM->end) && (TERM->start==0)) {
+ 	    TERM->start=-1; TERM->end=-1;
+ 	}
  	SendTokenBack=1;
  	/* Don't lose this token */
  	return;
!     } else {
! #ifdef DEBUG
! 	(void)fprintf(stderr,"got (\n");
! #endif
!     }
      GetNextToken(w);
!     TERM->start=DecNumber(w);
      GetNextToken(w);
!     if (*w!=')') {
! 	if (!KwrdCmp(w,"TO") && !KwrdCmp(w,"DOWNTO")){
! 	    Error("expected ')' or 'TO' or 'DOWNTO', could not continue");
! 	} else {
! 	    GetNextToken(w);
! 	    TERM->end=DecNumber(w);
! 	    GetNextToken(w);
! 	    if (*w!=')') {
! 		Warning("Expected ')'");
! 		SendTokenBack=1;
! 	    }
! 	}
!     } else {
! #ifdef DEBUG
! 	(void)fprintf(stderr,"--> just an element of index %d\n",TERM->start);
! #endif
! 	TERM->end=TERM->start;
!     }
! }
  
  
! void ChangInternal(Intern,name)
! struct SIGstruct *Intern;
! char *name;
  {
!     struct SIGstruct *Sptr;
      
! #ifdef DEBUG
!     (void)fprintf(stderr,"\n ** scanning into internals --> Int=%p",Intern);
! #endif
!     Sptr=Intern;
!     while(Sptr!=NULL){
! #ifdef DEBUG
! 	(void)fprintf(stderr,"\t <%s>",Sptr->name);
! #endif
! 	if (!strcmp(Sptr->name,name)) {
! 	    char i;
! 	    i = *name;
! 	    i= ( (i<='z') && (i>='a') ? i+('A'-'a') : i);
! 	    *name=i;
! #ifdef DEBUG
! 	    (void)fprintf(stderr,"\n *** %s : e' un segnale interno\n",name);
! #endif
! 	    return;
! 	}
! 	Sptr=Sptr->next;
!     }
! }
  /* -=[ GetInstance ]=-                              *
   * parses the netlist                               */
! struct Instance *GetInstance(name,Entity)
! char *name;
! struct ENTITYstruct *Entity;
  {
!     struct Cell       *cell;
!     struct Instance   *INST;
!     struct TERMstruct FORMterm;
!     struct TERMstruct ACTterm;
!     struct SIGstruct  *ACTtrms;
!     struct SIGstruct  *ACTptr;
!     struct Ports      *Cptr;
!     struct Ports      *Aptr;
      char   *w;
      char   LocalToken[MAXTOKENLEN];
!     int    j;
!     char   Iname[MAXTOKENLEN+10];
!     int    incF,incA;
!     int    iiF;
!     int    iF,iA;
  
!     w=&(LocalToken[0]);
!     GetNextToken(w);  /* : */
      GetNextToken(w);
!     cell=WhatGate(w,Entity->Components);
! #ifdef DEBUG
!     (void)fprintf(stderr,"\n=========================\nParsing instance %s of component %s\n==========================\n",name,cell->name);
! #endif
  
!     INST=(struct Instance *)calloc(1,sizeof(struct Instance));
!     if (INST==NULL) { 
! 	Error("Allocation Error or not enought memory !"); 
!     }
!     (void)strcpy(INST->name,name);
!     INST->what=WhatGate(w,Entity->Components);
!     INST->actuals=
! 	(struct Ports *)calloc(1,((INST->what)->npins)*sizeof(struct Ports));
!     if (INST->actuals==NULL){
! 	Error("Allocation Error or not enought memory !");
!     }
  
!     ACTtrms=(struct SIGstruct *)calloc(1,sizeof(struct SIGstruct));
!     if (ACTtrms==NULL) {
! 	Error("Allocation Error or not enought memory !"); 
!     }
! 	
  
      GetNextToken(w);
      if (!KwrdCmp(w,"PORT")) {
! 	Warning("PORT keyword missing","PORT");
!     }
  
      GetNextToken(w);
      if (!KwrdCmp(w,"MAP"))
***************
*** 1478,1609 ****
      if (*w!='(')
  	Warning("Expexcted '('");
  
-     alim=0;
-     first.next=NULL;
-     first.formal[0]='\0';
-     ptr= &first; clk=0;
-     clock[0]='\0';
      do{
! 	if (!alim) {
! 	    /* if the previous one was a power line, just overwrite *
! 	     * the last pointer..                                   */
! 	    if ( (ptr->next=(struct connections *)calloc(1,sizeof(struct connections)))==NULL ){
! 		FreeConns(&first);
! 		Error("Allocation error or not enought memory");
! 	    };
! 	    ptr=ptr->next;
! 	    ptr->next=NULL;
! 	};
  
- 	/* Get the formal terminal */
  	GetNextToken(w);
! 	alim= (KwrdCmp(w,VDD) || KwrdCmp(w,VSS)) ;
! 	if (!alim && !CheckFormal(ThisCell,w)) {
! 	    (void) sprintf(tmp,"formal terminal %s is not present into %s",w,ThisCell->name);
! 	    Error(tmp);
! 	};
! 
! 	if (!strcmp((ThisCell->output)->name,w)) {
! 	    if ((first.formal)[0]!='\0') {
! 		Warning("Multiple output lines in this gate");
! 		SendTokenBack=0;
! 	    };
! 	    (void) strcpy(first.formal,w);
! 	    output=1;
! 	    alim=1;
  	} else {
! 	    if ( (!gate) && (!strcmp(w,(ThisCell->clock)->name)) ) {
! 		clk=1;
! 		alim=1;
! 	    } else
! 		(void) strcpy(ptr->formal,w);
! 	};
  
! 	GetNextToken(w);
! 	SendTokenBack=(*w!='='); /* this is warning but we need to wait */
  
! 	GetNextToken(w);
! 	/* TAKE CARE: if the last was not an '=' this is  *
! 			   * still the last token read                      */
! 	if (SendTokenBack || (*w!='>'))
! 	    Warning("expected '=>'");
! 	    /* This is made because the 'keyword' here is "=>", made by *
! 	     * 2 short tokens                                           */
! 
! 	/* Get in 'tmp' the actual terminal */
! 	GetName(tmp);
! 	if (output) {
! 	    (void) strcpy(first.actual,tmp);
! 	    alim=1;
! 	    output=0;
  	} else {
! 	    if (clk) {
! 		if (clock[0]!='\0')
! 		    Warning("Multiple clock lines in this gate");
! 		(void) strcpy(clock,tmp);
! 		alim=1 ;
! 		clk=0;
  	    } else {
! 		(void) strcpy(ptr->actual,tmp);
! 	    };
! 	};
  
! 	GetNextToken(w);
! 	if (*w==')') break;
! 	if (*w!=',') {
! 	    VstError("expected ',' or ')'",";");
! 	    err=1;
! 	    SendTokenBack=1;
! 	    break;
! 	};
!     } while(1);
  
!     /* Ond of connections, these are the finals checks */
      GetNextToken(w);
!     if (*w!=';') Warning("expected ';'");
! 
!     if (first.formal[0]=='\0') {
! 	(void) sprintf(tmp,"*Error* Line %u : No outputs given, could *NOT* continue",line);
! 	Error(tmp);
!     };
! 
!     if (err) {
! 	/* ther was an error so print it... */
! 	/* ok, it's nonsense..              */
! 	(void) fprintf(Out," # error in source ...\n");
!     } else {
! 	/* ok now let's print'em ordered... */
! 	for(ptr=first.next; ; ptr=ptr->next) {
! 	    if (alim && (ptr->next==NULL)) break;
! 	    if (ptr==NULL) break;
! 	    (void) fprintf(Out,"%s=%s ",ptr->formal,ptr->actual);
! 	};
! 	/* the output is the last */
! 	(void) fprintf(Out,"%s=%s ",first.formal,first.actual);
! 	if (!gate)
! 	    (void) fprintf(Out,"%s %c",clock,INIT);
!     };
! 
!     /* Now let's check if all is connected */
!     if (!AllUsed(ThisCell)){
! 	(void) fprintf(stderr,"*Error* Line %u : Not all formals connected in %s\n",line,ThisCell->name);
! 	(void) fprintf(Out," # Not all formal connected \n");
!     };
! 
!     (void) fprintf(Out,"\n");
!     FreeConns(&first);
  }
  
  /* -=[ GetArchitecture ]=-                    *
   * parses the structure 'ARCHITECTURE'        */
! void GetArchitecture()
  {
      char *w;
      char LocalToken[MAXTOKENLEN];
      char name[MAXTOKENLEN];
      char msg[MAXTOKENLEN];
  
!     w= &(LocalToken[0]);
      /* type of architecture... */
      GetNextToken(w);
  
--- 1925,2120 ----
      if (*w!='(')
  	Warning("Expexcted '('");
  
      do{
! 	GetName(&FORMterm,Entity,1,cell);
! #ifdef DEBUG
! 	(void)fprintf(stderr,"\t formal : %s\n",FORMterm.name);
! #endif
  
  	GetNextToken(w);
! 	if (*w!='=') {
! 	    if (*w!='>') {
! 		Warning("Expected '=>'");
! 		SendTokenBack=1;
! 	    }
  	} else {
! 	    GetNextToken(w);
! 	    if (*w!='>') {
! 		Warning("Expected '=>'");
! 		SendTokenBack=1;
! 	    }
! 	}
  
! 	ACTptr=ACTtrms;
! 	do {
! 	    GetName(&ACTterm,Entity,0,cell);
! #ifdef DEBUG
! 	    (void)fprintf(stderr,"\t actual : %s .. %s\n",ACTterm.name,w);
! #endif
! 	    AddSIG(&ACTptr,ACTterm.name,'\0',ACTterm.start,ACTterm.end);
! 	    ChangInternal(Entity->Internals,ACTptr->name);
! #ifdef DEBUG
! 	    (void)fprintf(stderr,"\nafter GetInstance: %s %s\n",ACTterm.name,ACTptr->name);
! #endif
! 	    GetNextToken(w);
! 	} while (*w=='&');
  
! 	if ((*w!=',') && (*w!=')')) {
! 	    Error("Expected ')' or ','");
! 	}
! #ifdef DEBUG
! 	(void)fprintf(stderr,"----> %s\n",w);
! #endif
! 	if (FORMterm.start==FORMterm.end) {
! #ifdef DEBUG
! 	    if (DEBUG) (void)fprintf(stderr,"after if (FORMterm.start==FORMterm.end) {: %s %s\n",ACTterm.name,ACTptr->name);
! #endif
! 	    Cptr=(INST->what)->formals;
! 	    Aptr=INST->actuals; 
! 	    for(j=0; j<(INST->what)->npins; j++, Cptr++, Aptr++){
! 		if (KwrdCmp(Cptr->name,FORMterm.name)) break;
! 	    }
! 	    if ((ACTterm.start!=ACTterm.end) || ((ACTtrms->next)->next!=NULL)) {
! 		Warning("Actual vector's dimension differs to formal's one");
! 	    }
! #ifdef DEBUG
! 	    (void)fprintf(stderr,"value: %d %s\n",ACTptr->start,ACTptr->name);
! #endif
! 	    if (ACTptr->start!=-1) {
! 		if (isupper((ACTptr->name)[0])) {
! 		    (void)sprintf(Aptr->name,"%s_%d_",ACTptr->name,ACTterm.start);
! 		} else {
! 		    (void)sprintf(Aptr->name,"%s[%d]",ACTptr->name,ACTterm.start);
! 		}
! 	    } else {
! 		(void)strcpy(Aptr->name,ACTterm.name);
! 	    }
  	} else {
! #ifdef DEBUG
! 	    (void)fprintf(stderr,"\t\tthey are vectors --> formal from %d to %d\n",FORMterm.start,FORMterm.end);
! #endif
! 	    incF = (FORMterm.start>FORMterm.end ? -1 : 1 );
! 	    if (incF<0) {
! 		/*
! 		 * Downto
! 		 */
! 		iiF=FORMterm.end;
  	    } else {
! 		/*
! 		 *  To
! 		 */
! 		iiF=FORMterm.start;
! 	    }
! 	    ACTptr=ACTtrms;
! 	    incA=0; ACTptr->end=0; iA=0;
! 	    iF=FORMterm.start;
! 	    do {
! 		/* 
! 		 *  Let's look if we need a new element...
! 		 */
! 		if (iA==(ACTptr->end+incA)) {
! 		    if (ACTptr->next==NULL) {
! 			Error("Wrong vector size in assignement");
! 		    }
! 		    ACTptr=ACTptr->next;
! 		    incA = (ACTptr->start > ACTptr->end ? -1 : 1);
! 		    iA=ACTptr->start;
! #ifdef DEBUG
! 		    (void)fprintf(stderr,"ACTUAL changed!\ncurent : <%s> from %d to %d\n",ACTptr->name,ACTptr->start,ACTptr->end);
! #endif
! 		}
  
! 		/*
! 		 *  let's make the connection
! 		 */
! 		(void)sprintf(Iname,"%s[%d]",FORMterm.name,iiF);
! 		Cptr=(INST->what)->formals;
! 		Aptr=INST->actuals;
! 		for(j=0; j<(INST->what)->npins; j++, Cptr++, Aptr++){
! #ifdef DEBUG
! 		    (void)fprintf(stderr,"(%d)\tAptr->name=<%s>\tCptr->name=<%s>\tIname=<%s>\n",j,Aptr->name,Cptr->name,Iname);
! #endif
! 		    if (KwrdCmp(Cptr->name,Iname)) break;
! 		}
! 		if (ACTptr->start<0) {
! 		    /*
! 		     * ACTual is a BIT
! 		     */
! 		    if (isupper( (ACTptr->name)[0])) {
! 			(void)sprintf(Aptr->name,"%s",ACTptr->name);
! 		    } else {
! 			(void)sprintf(Aptr->name,"%s",ACTptr->name);
! 		    }
! 		} else {
! 		    /*
! 		     * ACTual is a VECTOR
! 		     */
! 		    if (isupper( (ACTptr->name)[0])) {
! 			(void)sprintf(Aptr->name,"%s_%d_",ACTptr->name,iA);
! 		    } else {
! 			(void)sprintf(Aptr->name,"%s[%d]",ACTptr->name,iA);
! 		    }
! 		}
! #ifdef DEBUG
! 		(void)fprintf(stderr,"%d)--> added ACTconn : <%s>\n",iF,Aptr->name);
! #endif
! 		iF+=incF; iA+=incA; iiF++;
! 	    } while (iF!=(FORMterm.end+incF));
! 	    ReleaseSIG(ACTtrms->next);
! #ifdef DEBUG
! 	    (void)fprintf(stderr,"---->release done<----\n ");
! #endif
! /*
! 	    for(iF=FORMterm.start, iA=ACTterm.start; iF!=FORMterm.end+incF; iF+=incF, iA+=incA) {
! 		sprintf(Iname,"%s[%d]",FORMterm.name,iF);
! 		Cptr=(INST->what)->formals;
! 		Aptr=INST->actuals;
! 		for(j=0; j<(INST->what)->npins; j++, Cptr++, Aptr++){
! 		    if (KwrdCmp(Cptr->name,Iname)) break;
! 		}
! 		if (isupper(ACTterm.name[0])) {
! 		    sprintf(Aptr->name,"%s_%d_",ACTterm.name,ACTterm.start);
! 		} else {
! 		    sprintf(Aptr->name,"%s[%d]",ACTterm.name,iA);
! 		}
! 	    }
! 	    if (iA!=ACTterm.end+incA) {
! 		Warning("Actual vector's dimension differs to formal's one");
! 	    }
! */
! 	}
!     } while (*w!=')');
  
!     free(ACTtrms);
      GetNextToken(w);
!     if (*w!=';') {
! 	Warning("expected ';'");
!     }
!     return INST;
  }
  
  /* -=[ GetArchitecture ]=-                    *
   * parses the structure 'ARCHITECTURE'        */
! void GetArchitecture(ENTITY)
! struct ENTITYstruct *ENTITY;
  {
+     struct Cell      *COMPOptr;
+     struct SIGstruct *SIGptr;
+     struct Instance  *INSTptr;
+     struct Cell      COMPOstart;
+     struct SIGstruct SIGstart;
+     struct Instance  INSTstart;
      char *w;
      char LocalToken[MAXTOKENLEN];
      char name[MAXTOKENLEN];
      char msg[MAXTOKENLEN];
+     
  
!     SIGptr=&SIGstart; SIGstart.next=NULL;
!     COMPOptr=&COMPOstart; COMPOstart.next=NULL;
!     SIGptr=&SIGstart;
! 
!     w=&(LocalToken[0]);
      /* type of architecture... */
      GetNextToken(w);
  
***************
*** 1611,1617 ****
      if (!KwrdCmp(w,"OF"))
  	Warning("expected syntax: ARCHITECTURE <type> OF <name> IS");
      GetNextToken(w);
!     (void) strcpy(name,w);
      GetNextToken(w);
      if (!KwrdCmp(w,"IS"))
  	Warning("expected syntax: ENTITY <name> IS");
--- 2122,2128 ----
      if (!KwrdCmp(w,"OF"))
  	Warning("expected syntax: ARCHITECTURE <type> OF <name> IS");
      GetNextToken(w);
!     (void)strcpy(name,w);
      GetNextToken(w);
      if (!KwrdCmp(w,"IS"))
  	Warning("expected syntax: ENTITY <name> IS");
***************
*** 1621,1662 ****
      do{
  	GetNextToken(w);
  	if (KwrdCmp(w,"COMPONENT")){
! 	    GetComponent();
  	} else {
  	    if (KwrdCmp(w,"SIGNAL")){
! 		GetSignal();
  	    } else {
  		if (KwrdCmp(w,"BEGIN")) break;
  		else {
! 		    (void) sprintf(msg,"%s unknown, skipped",w);
  		    Warning(msg);
  		    SendTokenBack=0; /* as we said we must skip it */
! 		};
! 	    };
! 	};
  	if (feof(In)) Error("Unespected EoF");
      } while(1);
  
      /* NETLIST */
      do{
  	GetNextToken(w);
  	if (KwrdCmp(w,"END")) {
  	    break;
  	} else {
! 	    /* there's no need to remember the name given to the  *
! 	     * instance, it's needed only the component name      */
! 	    GetInstance();
! 	};
  	if (feof(In)) Error("Unespected EoF");
      } while(1);
! 
      /* name of kind of architecture */
      GetNextToken(w);
!     /* End of architecture last ';'*/
!     GetNextToken(w);
!     if (*w!=';') Warning("extected ';'");
! };
  
  /* -=[ PARSE FILE ]=-                               *
   * switches between the two main states of          *
   * the program : the ENTITY prsing and the          *
--- 2132,2272 ----
      do{
  	GetNextToken(w);
  	if (KwrdCmp(w,"COMPONENT")){
! 	    GetComponent(&COMPOptr);
  	} else {
  	    if (KwrdCmp(w,"SIGNAL")){
! 		GetSignal(&SIGptr); 
  	    } else {
  		if (KwrdCmp(w,"BEGIN")) break;
  		else {
! 		    (void)sprintf(msg,"%s unknown, skipped",w);
  		    Warning(msg);
  		    SendTokenBack=0; /* as we said we must skip it */
! 		}
! 	    }
! 	}
  	if (feof(In)) Error("Unespected EoF");
      } while(1);
  
+     ENTITY->Internals=SIGstart.next;
+     ENTITY->Components=COMPOstart.next;
      /* NETLIST */
+     INSTptr=&INSTstart;
      do{
  	GetNextToken(w);
  	if (KwrdCmp(w,"END")) {
  	    break;
  	} else {
! 	    INSTptr->next=GetInstance(w,ENTITY);
! 	    INSTptr=INSTptr->next;
! 	}
  	if (feof(In)) Error("Unespected EoF");
      } while(1);
!     
!     ENTITY->Net=INSTstart.next;
!     
      /* name of kind of architecture */
      GetNextToken(w);
!     if (*w!=';') { 
! 	/* End of architecture last ';' */
! 	GetNextToken(w);
! 	if (*w!=';') Warning("extected ';'");
!     }
! }
  
+ void PrintSignals(msg,typ,Sptr)
+ char *msg;
+ char typ;
+ struct SIGstruct  *Sptr;
+ {
+     int i;
+     int incr;
+     
+     (void)fputs(msg,Out);
+     while(Sptr!=NULL){
+ 	if ((Sptr->dir==typ) && (!KwrdCmp(Sptr->name,CLOCK))) {
+ 	    if (Sptr->start==Sptr->end) {
+ 		(void)fprintf(Out,"%s ",Sptr->name);
+ 	    } else {
+ 		incr=( Sptr->start<Sptr->end ? 1 : -1 );
+ 		for(i=Sptr->start; i!=Sptr->end; i+=incr) {
+ 		    (void)fprintf(Out,"%s[%d] ",Sptr->name, i);
+ 		}
+ 	    }
+ 	}
+ 	Sptr=Sptr->next;
+     }
+     (void)fputs("\n",Out);
+ }
+ 
+ void PrintOrderedSignals(Sptr,Lptr)
+ struct Ports *Sptr;
+ struct LibCell *Lptr;
+ {
+     struct Ports *Lpptr;
+     int i;
+     
+     i=0; Lpptr=Lptr->formals;
+     while(i<Lptr->npins){
+ 	(void)fprintf(Out,"%s=%s ",Lpptr->name,Sptr->name);
+ 	Sptr++; i++; Lpptr++;
+     }
+     if (Lptr->clk[0]) (void)fputs(Sptr->name,Out);
+ }
+ 
+ 
+ void PrintSls(Entity)
+ struct ENTITYstruct *Entity;
+ {
+     struct Instance   *Iptr;
+     struct Ports      *Aptr;
+     struct Ports      *Fptr;
+     int j;
+ 
+     (void)fprintf(Out,"# *--------------------------------------*\n");
+     (void)fprintf(Out,"# |    File created by Vst2Blif v 1.1    |\n");
+     (void)fprintf(Out,"# |                                      |\n");
+     (void)fprintf(Out,"# |         by Roberto Rambaldi          |\n");
+     (void)fprintf(Out,"# |    D.E.I.S. Universita' di Bologna   |\n");
+     (void)fprintf(Out,"# *--------------------------------------*/\n\n");
+ 
+     (void)fprintf(Out,"\n.model %s\n",(Entity->EntityPort)->name);
+     PrintSignals(".input ",'i',(Entity->EntityPort)->io);
+     PrintSignals(".output ",'o',(Entity->EntityPort)->io);
+     if (CLOCK[0]) {
+ 	(void)fprintf(Out,".clock %s",CLOCK);
+     }
+     (void)fputs("\n\n",Out);
+ 	
+     Iptr=Entity->Net;
+     while(Iptr!=NULL){
+ 	switch ( (Iptr->what)->type ) {
+ 	  case 'S' :
+ 	      (void)fprintf(Out,".subckt %s ",(Iptr->what)->name);
+ 	      Aptr=Iptr->actuals; Fptr=(Iptr->what)->formals;
+ 	      for(j=0, Aptr++, Fptr++ ; j<(Iptr->what)->npins-1; j++, Aptr++,Fptr++){
+ 		  (void)fprintf(Out,"%s=%s ",Fptr->name,Aptr->name);
+ 	      }
+ 	      break;
+ 	    case 'L':
+ 	      (void)fprintf(Out,".latch %s ",(Iptr->what)->name);
+ 	      PrintOrderedSignals(Iptr->actuals,WhatLibGate((Iptr->what)->name,LIBRARY));
+ 	      (void)fprintf(Out," %c",INIT);
+ 	      break;
+ 	    case 'G':
+ 	      (void)fprintf(Out,".gate %s ",(Iptr->what)->name);
+ 	      PrintOrderedSignals(Iptr->actuals,WhatLibGate((Iptr->what)->name,LIBRARY));
+ 	      break;
+ 	  }
+ 	(void)fputs("\n",Out);
+ 	Iptr=Iptr->next;
+     }
+     (void)fputs("\n\n",Out);
+ 
+ 
+ }
+ 
+ 
  /* -=[ PARSE FILE ]=-                               *
   * switches between the two main states of          *
   * the program : the ENTITY prsing and the          *
***************
*** 1663,1688 ****
   * ARCHITECTURE one.                                */  
  void ParseFile()
  {
      char *w;
      char LocalToken[MAXTOKENLEN];
!     int flag;
!     int entity;
  
! 
!     w= &(LocalToken[0]);
!     (void) fprintf(Out,"# File created by vst2blif ver 1.0\n");
!     (void) fprintf(Out,"#        by Roberto Rambaldi \n");
!     (void) fprintf(Out,"#   D.E.I.S. Universita' di Bologna\n");
      do {
  
  	/* ENTITY CLAUSE */
  	flag=0;
- 	entity=0;
  	do {
  	    GetNextToken(w);
  	    if ((flag=KwrdCmp(w,"ENTITY"))) {
! 		GetEntity();
! 		entity=1;
  	    } else {
  		if (*w=='\0') break;
  		VstError("No Entity ???","ENTITY");
--- 2273,2292 ----
   * ARCHITECTURE one.                                */  
  void ParseFile()
  {
+     struct ENTITYstruct LocalENTITY;
      char *w;
      char LocalToken[MAXTOKENLEN];
!     int  flag;
  
!     w=&(LocalToken[0]);
      do {
  
  	/* ENTITY CLAUSE */
  	flag=0;
  	do {
  	    GetNextToken(w);
  	    if ((flag=KwrdCmp(w,"ENTITY"))) {
! 		GetEntity(&(LocalENTITY.EntityPort));
  	    } else {
  		if (*w=='\0') break;
  		VstError("No Entity ???","ENTITY");
***************
*** 1689,1695 ****
  	        /* After this call surely flag will be true *
  		 * in any other cases the program will stop *
  		 * so this point will be never reached ...  */
! 	    };
  	} while(!flag);
  
  	/* ARCHITECTURE CLAUSE */
--- 2293,2299 ----
  	        /* After this call surely flag will be true *
  		 * in any other cases the program will stop *
  		 * so this point will be never reached ...  */
! 	    }
  	} while(!flag);
  
  	/* ARCHITECTURE CLAUSE */
***************
*** 1697,1716 ****
  	do {
  	    GetNextToken(w);
  	    if ((flag=KwrdCmp(w,"ARCHITECTURE"))){
! 		GetArchitecture();
  	    } else {
  		if (*w=='\0') break;
  		VstError("No Architecture ???","ARCHITECTURE");
  	        /* it's the same as the previous one         */
! 	    };
  	} while (!flag);
  	/* end of the model */
- 	if (entity) (void) fprintf(Out,"\n.end\n");
  
      } while (!feof(In));
  
! };
  
  /* -=[ main ]=-                                     */
  int main(argc,argv)
  int  argc;
--- 2301,2321 ----
  	do {
  	    GetNextToken(w);
  	    if ((flag=KwrdCmp(w,"ARCHITECTURE"))){
! 		GetArchitecture(&LocalENTITY);
  	    } else {
  		if (*w=='\0') break;
  		VstError("No Architecture ???","ARCHITECTURE");
  	        /* it's the same as the previous one         */
! 	    }
  	} while (!flag);
  	/* end of the model */
  
      } while (!feof(In));
  
!     PrintSls(&LocalENTITY);
  
+ }
+ 
  /* -=[ main ]=-                                     */
  int main(argc,argv)
  int  argc;
***************
*** 1724,1727 ****
      CloseAll();
  
      exit(0);
! };
--- 2329,2333 ----
      CloseAll();
  
      exit(0);
! }
! 
